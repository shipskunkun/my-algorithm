## 读算法40讲

2020.5.8

## 03 算法复杂度

递归的算法时间复杂度？

子问题的规模 * 子问题的处理时间

子问题的规模 =  树的个数和，O(2^n)

常见的四种递归

1. 二分查找，O(logn)
2. 二叉树的遍历，O(n), 每个结点遍历一次且仅遍历一次
3. 排序矩阵查找，O(n)
4. 快排、归并，O(nlogn)
 
 
## 04 LeetCode

91道算法题

27，43，21 = 97

## 08 

括号字符串是否有效

## 58 五个代码模板

37法则

1. 任务密度
2. 博弈论
3. 凯利公式




递归
	
	递归的终止条件
	调用自己，level+1
	
DFS  
BFS
	
	使用队列
	while (q.length)
二分查找
为什么要写， right - left， 防止数据越界
	
	
	let left = 0
	let right = arr.length - 1
	
	while(left < = right) {
		mid = left + (right - left)/2
		if(arr[mid] == target) {
			return result
		}
		else if(mid < target) {
			left = mid + 1
		}
		else {
			right = mid - 1
		}
	}
	
dp
	
	定义状态
	dp = new int [m+1][n+1]
	
	定义初始状态
	dp[0][1] = x
	dp[0][1] = y
	
	状态推导
	for(let i = 0; i <= m ; i++) {
		for(let j = 0; j <= n ; j++) {
			dp[i][j] = Math.max( dp[i][j-1] ...)
		}
	}
	
	return dp[m][n]


位运算
	
	x & 1 == 1 or  0 判断技术偶数
	

## 59

1. 搞清楚题目要干什么
2. 可能所有的解答
3. 写代码
4. 测试用例


不要当成考官。 

更多的是沟通和交流，探讨和交流一个问题







