## 读算法40讲

63节课时。

2020.5.8 开始~  

5.8日，0-12章  
5.9日，12章-62章，过了一遍，剩10道题


###TODO:   

40，41   
47、48   
52、54 


## 03 算法复杂度

递归的算法时间复杂度？

子问题的规模 * 子问题的处理时间

子问题的规模 =  树的个数和，O(2^n)

常见的四种递归

1. 二分查找，O(logn)
2. 二叉树的遍历，O(n), 每个结点遍历一次且仅遍历一次
3. 排序矩阵查找，O(n)
4. 快排、归并，O(nlogn)
 
 
## 04 LeetCode

91道算法题

27，43，21 = 97

## 08 括号字符串是否有效


## 11 第k大的数

1. 使用快排的时间复杂度是

  nlogn

2. 使用k个元素的小根堆，

	遍历n个元素，对每一个元素，直接插入 小根堆，或者调整小根堆
	
	时间复杂度： nlogk  
	空间复杂度：O(k)


向大小为 k 的堆中添加元素的时间复杂度为 O(logk)，我们将重复该操作 N 次，故总时间复杂度为 O(Nlogk)。



## 12. 宽度为k 的滑动窗口最大值

大根堆

队列，始终保持队头是 top

## 14. 有效的字母异位词

attaprx  xatatpr

1. 排序是否一致, nlogn
2. 记录每个单词出现的个数

## 16. 三数之和

[-1, 0, 1, 2, -1, -4]

a+b+c = 0

1. 暴力解法，O(n^3)
2. c = -(a+b)  Set()  

		O(n^2) 空间复杂度 O(n)
		
		如何解决重复问题？？？
		 
3. sort find

		整个数组排序，nlogn
		后面就是两数之和了。
		算法时间复杂度，O(n^2)，空间复杂度，O(1)


map set  最常用来，查询和计数


## 17.二叉树、二叉搜索树

二叉搜索树：
	
	空树，或者具有以下性质的二叉树：
	
	左子树上所有节点值 < 根节点值
	右子树上所有节点值 >根节点的值
	左右子树也是二叉搜索树

## 18. 验证二叉搜索树

1. 中序遍历二叉搜索树，是否是升序排列
	
	没有要求保存所有的节点，只需要当前节点值 > 前继节点值 即可
	
2. 递归
	
	找左孩子的最大值 < root.val  
	找右孩子的最小值 > root.val 


## 21. 递归和分治

递归：

自己调用自己，然后有终止条件

分治：
	

并行解决子问题，然后合并

## 22. Pow(x, n)


1. 调用Math 函数，O(1)
2. 暴力 O(n), 调用n次
3. 分治
	
	n 是偶数的， y = x^(n/2), result = y * y  
	n 是奇数， y = x^(n-1/2), result = y * y * x  
	
	时间复杂度 logn
	
	
## 23. 众数

1. 暴力， 对每一个数，第二层又记录出现的次数，O(n^2)
2. map， {x: count }, O(n), 空间复杂度： O(n)
3. sort, 中间的数， nlogn
4. 投票法
5. 分治， nlogn
	left 和 right 的众数
	
## 24. 贪心

条件：
	
	问题能够分成子问题来解决
	子问题的最优解，能够地推到最终问题的最优解
	这种子问题最优解成为最优子结构
	
贪心不同于dp:
	
	不能回退
	对每个子问题的解决方案都做出选择，但不一定是问题的最优解
	dp会保存之前的计算结果，并根据以前的结果对当前进行选择，有回退功能
	

## 25. 买卖股票
## 26.广度优先

队列

## 27. 深度优先

栈
	
## 29. 二叉树的最大和最小深度

1. dfs
	
	没明白，为什么，当没有左孩子的时候，最小深度，是右子树的最小深度
	
2. bfs
	 
	 终止条件，叶子节点

## 30.生成有效果括号

递归，回溯

## 34. 二分查找

条件是有序列表

## 39. 位运算

程序中所有数，在内存中，都是二进制的形式进行存储的，直接对整数在内存中的二进制位进行操作。

对内存数据进行操作，不需要转成十进制，处理熟读非常快


110 &  1101 = 0010 

^ 异或，两个不一样true  
~ 取反  
```<<```  左移，高位丢弃，低位补0， 左移一位 * 2  
```>>``` 右移，  

位运算操作的特点
	
	x ^ 0 = x
	x ^ 1s = ~x  //全1
	x ^ (~x) = 1 
	x ^ x = 0  // important 
	a ^ b = c =>  a ^ c = b, b ^ c = a  // swap
	a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c
	
	
最常用的 位运算：



	x ^ 1 == 1 判断奇偶：  
	x ^ 1 == 0 奇数    
	x = x & (x - 1) 清零最低位的1
	x & -x 得到最低位的 1


## 40. 位1的个数



## 47. 乘积最大子序列

## 48. 股票买卖

## 49. 最长上升子序列

## 51. 编辑距离

## 52. 并cha

## 54. 岛屿个数

## 58. 五个代码模板

37法则

1. 任务密度
2. 博弈论
3. 凯利公式




递归
	
	递归的终止条件
	调用自己，level+1
	
DFS  
BFS
	
	使用队列
	while (q.length)
二分查找
为什么要写， right - left， 防止数据越界
	
	
	let left = 0
	let right = arr.length - 1
	
	while(left < = right) {
		mid = left + (right - left)/2
		if(arr[mid] == target) {
			return result
		}
		else if(mid < target) {
			left = mid + 1
		}
		else {
			right = mid - 1
		}
	}
	
dp
	
	定义状态
	dp = new int [m+1][n+1]
	
	定义初始状态
	dp[0][1] = x
	dp[0][1] = y
	
	状态推导
	for(let i = 0; i <= m ; i++) {
		for(let j = 0; j <= n ; j++) {
			dp[i][j] = Math.max( dp[i][j-1] ...)
		}
	}
	
	return dp[m][n]


位运算
	
	x & 1 == 1 or  0 判断技术偶数
	x & x - 1  清零最低位的 1
	x & -x 得到最低位的1

## 59

1. 搞清楚题目要干什么
2. 可能所有的解答
3. 写代码
4. 测试用例


不要当成考官。 

更多的是沟通和交流，探讨和交流一个问题







