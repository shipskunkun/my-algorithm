## 5. 二叉树



## 题目

	112. 路径总和
	113. 路径总和 II
	114. 首个共同祖先
	104. 二叉树的最大深度
	102. 二叉树的层序遍历




### 112. 路径总和

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例: 
给定如下二叉树，以及目标和 sum = 22，

返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。


### 错误解法：

#### 这不是先序访问二叉树，我们需要返回，左子树右子树访问结果

```javascript
var hasPathSum = function(root, sum) {
    if(!root) return false;
    if(root.left == null && root.right == null && root.val == sum) return true;
    hasPathSum(root.left, sum - root.val);
    hasPathSum(root.right, sum - root.val);
    return false
};
```


### 解题思路

### 解法一
遍历整棵树：如果当前节点不是叶子，对它的所有孩子节点，递归调用 hasPathSum 函数，其中 sum 值减去当前节点的权值；  

时间复杂度：我们访问每个节点一次，时间复杂度为 O(N)O(N) ，其中 NN 是节点个数。
  
空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 N 次（树的高度），因此栈的空间开销是 O(N) 。但在最好情况下，树是完全平衡的，高度只有 log(N)，因此在这种情况下空间复杂度只有 O(log(N)) 。   

### 代码
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
    if(!root) return false;
    if(root.left == null && root.right == null && root.val == sum) return true;
    return hasPathSum(root.left, sum - root.val) ||  hasPathSum(root.right, sum - root.val) ;
};
```

### 解法二

当我们访问到叶子节点时，如果之前访问的节点值总和 + 当前叶子节点 val == sum, 则返回true，否则返回false

时间复杂度：O(N) 空间复杂度，评价情况，O(log(N)) ， 和解法一一致

### 代码

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
   return dps (root, 0, sum)
};

function dps (root, cur, sum) {
    if(!root) return false
    cur = root.val + cur
    if(cur == sum && root.left == null && root.right == null) return true;
    else {
        return dps(root.left, cur, sum) || dps(root.right, cur, sum)
    }
}

```

### 113. 路径总和 II
给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

说明: 叶子节点是指没有子节点的节点。
给定如下二叉树，以及目标和 sum = 22，

### 错误原因：

为什么错了？？？
尝试执行一下代码过程


```javascript
var pathSum = function(root, sum) {
    let arr = [];
    let path = [];
    dfs(root, path, arr, sum);
    return arr;
};

function dfs(root, path, arr, sum) {
    if(!root) return
    path.push(root.val)
    if(root.val == sum && !root.left && !root.right) {
        arr.push(path)
        return 
    }
    dfs(root.left, path, arr, sum - root.val);
    dfs(root.right, path, arr, sum - root.val);
    path.pop();
}
```







### 面试题 04.08. 首个共同祖先

设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。

例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]

	输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
	输入: 3
	解释: 节点 5 和节点 1 的最近公共祖先是节点 3。

示例 2:

	输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
	输出: 5
	解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。




### 解题思路
### 方法一，递归

![0f4ca3373202d322ee1f210ae7272186021c42ba9a4b5cd7d3b775c98af0b8bd-0408.png](https://pic.leetcode-cn.com/0547f2e34e4f9ea477ed98ccd297b02e64b06f4e198e88724c0f4b7c5e77eefc-0f4ca3373202d322ee1f210ae7272186021c42ba9a4b5cd7d3b775c98af0b8bd-0408.png)

三种情况，要么p q 有一个是root  
要么p, q 分别在 root 左孩子，右孩子上  
要么，p，q z都在root的同一侧  

### 代码

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if(!root || root == p || root == q) {
        return root
    }
    let left = lowestCommonAncestor(root.left, p, q);
    let right = lowestCommonAncestor(root.right, p, q);
    if(left && right)  return root
    return left ? left : right;
};

```

### 方法二

使用两个栈，记录根节点到p、根节点到q的路径  
比如左图的例子中  
root = [3,5,1,6,2,0,8,null,null,7,4], p = 6, q = 4  
那么，l1=[3,5,6]  l2=[3,5,2,4]  
最近节点应该是5，我们从左到右找，找节点值相等，让该节点为共同节点，直到不相等为止


### 代码

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    let l1 = [];
    let l2 = [];
    getPath(root, p, l1);
    getPath(root, q, l2);

    let l3 = l1.length < l2.length ? l1.length : l2.length;
    let common = null;
    for(let i = 0; i < l3; i++) {
        if(l1[i].val == l2[i].val) {
            common = l1[i];
        }
        else {
            break;
        }
    }
    return common;
};

function getPath(root, v, path) {
    if(!root) {
        return false
    }
    path.push(root);
    if(root.val == v.val) {
        return true
    }
    if( getPath(root.left, v, path)) return true;
    if( getPath(root.right, v, path)) return true;
    path.pop();
    return false;
}
```


### 104. 二叉树的最大深度


给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
	给定二叉树 [3,9,20,null,null,15,7]，

返回它的最大深度 3 。


### 解题思路
此处撰写解题思路

### 代码

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if(!root) return 0
    let l = maxDepth(root.left) + 1;
    let r = maxDepth(root.right) + 1;
    return l > r ? l : r
};
```





### 102. 二叉树的层序遍历


给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

示例：
	
	二叉树：[3,9,20,null,null,15,7],
	
返回其层次遍历结果：

	[
	  [3],
	  [9,20],
	  [15,7]
	]
	
	
### 解题思路

递归，注意当root = null 时候的情况
迭代，使用栈，注意两个判断条件，一个是栈非空，第二个是这一层元素个数 > 0

### 递归

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    let arr = [];
    dfs (root, arr, 0)
    return arr;
};
function dfs(root, arr, layer) {
    if(!root) return;
    if(!arr[layer]) arr[layer] = [];
    arr[layer].push(root.val);
    dfs(root.left, arr, layer + 1);
    dfs(root.right, arr, layer + 1) 
}
```



### 迭代

### 代码

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if(!root) return [];
    let arr = [];
    let path = [root];
    let layer = 0;
    while(path.length) {
        arr[layer] = [];
        let n = path.length;
        while(n-- > 0) {
            let node = path.shift();
            arr[layer].push(node.val);
            if (node.left) { path.push(node.left) };
            if (node.right){ path.push(node.right)};
        }
        layer++;
    }
    return arr;
};
```




