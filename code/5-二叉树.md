## 5. 二叉树



## 题目
	
	1. 重建二叉树
	2. 路径总和
	3. 路径总和 II
	4. 首个共同祖先
	5. 二叉树的最大深度
	6. 二叉树的层序遍历
	7. 617. 合并二叉树
	8. 94. 二叉树的中序遍历
	9. 98. 验证二叉搜索树




### 1. 重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

 

例如，给出

	前序遍历 preorder = [3,9,20,15,7]
	中序遍历 inorder = [9,3,15,20,7]


// i有两个含义，一个是根节点在中序遍历结果中的下标，另一个是当前左子树的节点个数

### 错误解法1 
原因：边界情况错误

```javascript
var buildTree = function(preorder, inorder) {
    if(!preorder.length && !inorder.length) return null
    
    let val = preorder[0];
    let root = new TreeNode(val);
    let i = inorder.indexOf(val);

    root.left = buildTree(preorder.slice(1, 1+i), inorder.slice(0, i));

    root.right = buildTree(preorder.slice(i+1), inorder.slice(i+1));
    return root;
};
```


### 解题思路
前序遍历，第一个值肯定是根节点		
在中序遍历中，寻找根节点位置，= 当前左子树的节点个数  
递归建立该节点的左孩子，右孩子  
注意边界情况  

时间复杂度：O(n)。对于每个节点都有创建过程以及根据左右子树重建过程。		
空间复杂度：O(n)。存储整棵树的开销。

### 代码

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {

    if(!preorder.length || !inorder.length) return null

    let val = preorder[0];
    let root = new TreeNode(val);
    let i = inorder.indexOf(val);

    root.left = buildTree(preorder.slice(1, 1+i), inorder.slice(0, i));

    root.right = buildTree(preorder.slice(i+1), inorder.slice(i+1));
    return root;
};
```

### 2. 路径总和

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例: 
给定如下二叉树，以及目标和 sum = 22，

返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。


### 错误解法：

#### 这不是先序访问二叉树，我们需要返回，左子树右子树访问结果

```javascript
var hasPathSum = function(root, sum) {
    if(!root) return false;
    if(root.left == null && root.right == null && root.val == sum) return true;
    hasPathSum(root.left, sum - root.val);
    hasPathSum(root.right, sum - root.val);
    return false
};
```


### 解题思路

### 解法一
遍历整棵树：如果当前节点不是叶子，对它的所有孩子节点，递归调用 hasPathSum 函数，其中 sum 值减去当前节点的权值；  

时间复杂度：我们访问每个节点一次，时间复杂度为 O(N)O(N) ，其中 NN 是节点个数。
  
空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 N 次（树的高度），因此栈的空间开销是 O(N) 。但在最好情况下，树是完全平衡的，高度只有 log(N)，因此在这种情况下空间复杂度只有 O(log(N)) 。   

### 代码
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
    if(!root) return false;
    if(root.left == null && root.right == null && root.val == sum) return true;
    return hasPathSum(root.left, sum - root.val) ||  hasPathSum(root.right, sum - root.val) ;
};
```

### 解法二

当我们访问到叶子节点时，如果之前访问的节点值总和 + 当前叶子节点 val == sum, 则返回true，否则返回false

时间复杂度：O(N) 空间复杂度，评价情况，O(log(N)) ， 和解法一一致

### 代码

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
   return dps (root, 0, sum)
};

function dps (root, cur, sum) {
    if(!root) return false
    cur = root.val + cur
    if(cur == sum && root.left == null && root.right == null) return true;
    else {
        return dps(root.left, cur, sum) || dps(root.right, cur, sum)
    }
}

```

### 3. 路径总和 II
给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

说明: 叶子节点是指没有子节点的节点。
给定如下二叉树，以及目标和 sum = 22，

### 错误原因：

为什么错了？？？
尝试执行一下代码过程

不能直接传入 path!   
path 是地址引用，所有的path都会最后变成 []    
为什么在path后，不用 cur = cur - root.val

每次执行dfs, 相当于内部的 cur2 = cur;  
不会影响外部的 cur


```javascript
var pathSum = function(root, sum) {
    let arr = [];
    let path = [];
    dfs(root, path, arr, sum);
    return arr;
};

function dfs(root, path, arr, sum) {
    if(!root) return
    path.push(root.val)
    if(root.val == sum && !root.left && !root.right) {
        arr.push(path)
        return 
    }
    dfs(root.left, path, arr, sum - root.val);
    dfs(root.right, path, arr, sum - root.val);
    path.pop();
}
```

打印可以看到执行过程

[5,4,8] 9

	开始 0 []
	开始 5 [ 5 ]
	结束 9 [ 5 ]
	开始 5 [ 5 ]
	结束 13 [ 5 ]
	结束 5 []


```javascript
var pathSum = function(root, sum) {
    let cur = 0;
    let arr = [];
    let path = [];
    dfs(root, 0, path, arr, sum)
    return arr;
};

function dfs(root, cur, path, arr, sum) {
    if(!root) return;
    console.log("开始", cur, path);
    path.push(root.val);
    cur = cur + root.val;
    if(cur == sum && !root.left && !root.right) {
        arr.push([...path]);
        // arr.push(path)
        // console.log(path)
    }
    dfs(root.left, cur, path, arr, sum);
    dfs(root.right, cur, path, arr, sum);
    path.pop();
    console.log("结束", cur, path);
}
```


### 解题思路
深度搜索所有从根节点到叶结点的路径，检查各路径上所有节点的值的和是 否为sum。  
注意，当满足结果的路径时，深拷贝path副本，而不是path本身  
因为在js中，参数是值传递，当参数是引用类型时，是复制参数的地址  

### 代码一

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {number[][]}
 */
var pathSum = function(root, sum) {
    let cur = 0;
    let arr = [];
    let path = [];
    dfs(root, 0, path, arr, sum)
    return arr;
};

function dfs(root, cur, path, arr, sum) {
    if(!root) return;
    path.push(root.val);
    cur = cur + root.val;
    if(cur == sum && !root.left && !root.right) {
        arr.push([...path]);
    }
    dfs(root.left, cur, path, arr, sum);
    dfs(root.right, cur, path, arr, sum);
    path.pop();
}
```
### 代码二
```javascript
var pathSum = function(root, sum) {
    let cur = 0;
    let arr = [];
    let path = [];
    dfs(root, sum, path, arr)
    return arr;
};

function dfs(root, cur, path, arr) {
    if(!root) return;
    path.push(root.val);
    cur = cur - root.val;
    if(cur == 0 && !root.left && !root.right) {
        arr.push([...path]);
    }
    dfs(root.left, cur, path, arr);
    dfs(root.right, cur, path, arr);
    path.pop();
}
```









### 面试题 04. 首个共同祖先

设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。

例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]

	输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
	输入: 3
	解释: 节点 5 和节点 1 的最近公共祖先是节点 3。

示例 2:

	输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
	输出: 5
	解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。




### 解题思路
### 方法一，递归

![0f4ca3373202d322ee1f210ae7272186021c42ba9a4b5cd7d3b775c98af0b8bd-0408.png](https://pic.leetcode-cn.com/0547f2e34e4f9ea477ed98ccd297b02e64b06f4e198e88724c0f4b7c5e77eefc-0f4ca3373202d322ee1f210ae7272186021c42ba9a4b5cd7d3b775c98af0b8bd-0408.png)

三种情况，要么p q 有一个是root  
要么p, q 分别在 root 左孩子，右孩子上  
要么，p，q z都在root的同一侧  

### 代码

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if(!root || root == p || root == q) {
        return root
    }
    let left = lowestCommonAncestor(root.left, p, q);
    let right = lowestCommonAncestor(root.right, p, q);
    if(left && right)  return root
    return left ? left : right;
};

```

### 方法二

使用两个栈，记录根节点到p、根节点到q的路径  
比如左图的例子中  
root = [3,5,1,6,2,0,8,null,null,7,4], p = 6, q = 4  
那么，l1=[3,5,6]  l2=[3,5,2,4]  
最近节点应该是5，我们从左到右找，找节点值相等，让该节点为共同节点，直到不相等为止


### 代码

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    let l1 = [];
    let l2 = [];
    getPath(root, p, l1);
    getPath(root, q, l2);

    let l3 = l1.length < l2.length ? l1.length : l2.length;
    let common = null;
    for(let i = 0; i < l3; i++) {
        if(l1[i].val == l2[i].val) {
            common = l1[i];
        }
        else {
            break;
        }
    }
    return common;
};

function getPath(root, v, path) {
    if(!root) {
        return false
    }
    path.push(root);
    if(root.val == v.val) {
        return true
    }
    if( getPath(root.left, v, path)) return true;
    if( getPath(root.right, v, path)) return true;
    path.pop();
    return false;
}
```


### 5. 二叉树的最大深度


给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
	给定二叉树 [3,9,20,null,null,15,7]，

返回它的最大深度 3 。


### 解题思路
此处撰写解题思路

### 代码

```javascript
var maxDepth = function(root) {
    if(!root) return 0
    let l = maxDepth(root.left) + 1;
    let r = maxDepth(root.right) + 1;
    return l > r ? l : r
};
```





### 6. 二叉树的层序遍历


给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

示例：
	
	二叉树：[3,9,20,null,null,15,7],
	
返回其层次遍历结果：

	[
	  [3],
	  [9,20],
	  [15,7]
	]
	
	
### 解题思路

递归，注意当root = null 时候的情况
迭代，使用栈，注意两个判断条件，一个是栈非空，第二个是这一层元素个数 > 0

### 递归

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    let arr = [];
    dfs (root, arr, 0)
    return arr;
};
function dfs(root, arr, layer) {
    if(!root) return;
    if(!arr[layer]) arr[layer] = [];
    arr[layer].push(root.val);
    dfs(root.left, arr, layer + 1);
    dfs(root.right, arr, layer + 1) 
}
```



### 迭代

### 代码

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if(!root) return [];
    let arr = [];
    let path = [root];
    let layer = 0;
    while(path.length) {
        arr[layer] = [];
        let n = path.length;
        while(n-- > 0) {
            let node = path.shift();
            arr[layer].push(node.val);
            if (node.left) { path.push(node.left) };
            if (node.right){ path.push(node.right)};
        }
        layer++;
    }
    return arr;
};
```


### 7.617. 合并二叉树

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

### 错误原因：没有考虑 null.left

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} t1
 * @param {TreeNode} t2
 * @return {TreeNode}
 */
var mergeTrees = function(t1, t2) {
    let node = new TreeNode();
    if(!t1 && !t2) return 
    if(t1 && t2) {
        node.val = t1.val + t2.val;
    }
    else if(t1.val) {
        node.val = t1.val
    }
    else {
        node.val = t2.val;
    }
    node.left = mergeTrees(t1.left, t2.left);
    node.right = mergeTrees(t1.right, t2.right);
    return node;
};
```



### 8.二叉树的中序遍历

给定一个二叉树，返回它的中序 遍历。

示例:

输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？


中序：左根右

### 解题思路
递归：

  递归很简单，先递归左孩子，然后访问根节点，最后递归右孩子

迭代：

1. 先找到最左边的节点，表明改节点的左孩子已经over
2. 弹出，即最左节点的根节点访问了。
3. 如果弹出节点有右孩子，把它的右孩子入栈入栈
4. 否则，表示这个节点既没有左孩子，也没有右孩子
5. 栈继续弹出

### 方法一，递归

```javascript
var inorderTraversal = function(root) {
    let arr = [];
    dfs(root,arr);
    return arr
};

function dfs(root, arr) {
    if(!root) return;
    dfs(root.left, arr);
    arr.push(root.val);
    dfs(root.right, arr);
}
```

### 方法二，迭代

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 * 
 * 
 */
var inorderTraversal = function(root) {
    let res = [], stack = []
  while (root || stack.length) {
    while(root) {
        stack.push(root);
        root = root.left;
    }
    root = stack.pop();
    res.push(root.val);
    root = root.right;
  }
  return res
};
```





### 9. 验证二叉搜索树


给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
示例 1:

	输入:
	    2
	   / \
	  1   3
	输出: true
	示例 2:
	
	输入:
	    5
	   / \
	  1   4
	     / \
	    3   6
	输出: false
	解释: 输入为: [5,1,4,null,null,3,6]。
	     根节点的值为 5 ，但是其右子节点值为 4 。


### 解题思路

1. 递归判断，

如果根节点的值 <= 左节点，或者 >= 右节点，返回false  ，注意 = 也不行
在根节点和，左右子树上分别执行


2. 中序遍历二叉树，生成数组，然后判断，是否每一个节点值 < 后继节点


### 方法一

```javascript
var isValidBST = function(root) {
    return recursion(root, -Infinity, Infinity)
};

function recursion(root, low, high) {
    if(!root) return true
    if(root.val <= low || root.val >= high) return false
    return recursion(root.left, low, root.val) && recursion(root.right, root.val, high);
}
```



### 方法二

```javascript
function dfs(root, arr) {
    if(!root) return;
    dfs(root.left, arr);
    arr.push(root.val);
    dfs(root.right, arr);
}
var isValidBST = function(root) {
    let arr = [];
    dfs(root, arr);
    for(let i = 0; i <  arr.length - 1; i++) {
        if(arr[i] >= arr[i+1]){
            return false
        }
    }
    return true
};
```



