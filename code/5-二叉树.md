## 5. 二叉树


## 基础知识

二叉树的深度遍历，就是前序遍历




先搞清楚一个问题

```
function a(x) {
	if(x == 3) return
	else {
		console.log(x);
	}
}
for(let i = 0; i < 6; i++) {
	a(i)
}
```
会不会执行3 后面的？

退出循环是break	
return是退出函数并返回	


```
function test() {
	result = [];
	for(let i = 0; i < 10; i++) {
		result.push(i)
		return result
	}
}
console.log(test())

function test() {
	result = [];
	for(let i = 0; i < 10; i++) {
		b(result, i)
	}
	return result
}
function b(a, i) {
	a.push(i)
	return a
}
console.log(test())
```

## 题目

	112. 路径总和




### 112. 路径总和

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例: 
给定如下二叉树，以及目标和 sum = 22，

返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。


### 错误解法：

#### 这不是先序访问二叉树，我们需要返回，左子树右子树访问结果

```javascript
var hasPathSum = function(root, sum) {
    if(!root) return false;
    if(root.left == null && root.right == null && root.val == sum) return true;
    hasPathSum(root.left, sum - root.val);
    hasPathSum(root.right, sum - root.val);
    return false
};
```


### 解题思路

### 解法一
遍历整棵树：如果当前节点不是叶子，对它的所有孩子节点，递归调用 hasPathSum 函数，其中 sum 值减去当前节点的权值；  

时间复杂度：我们访问每个节点一次，时间复杂度为 O(N)O(N) ，其中 NN 是节点个数。
  
空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 N 次（树的高度），因此栈的空间开销是 O(N) 。但在最好情况下，树是完全平衡的，高度只有 log(N)，因此在这种情况下空间复杂度只有 O(log(N)) 。   

### 代码
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
    if(!root) return false;
    if(root.left == null && root.right == null && root.val == sum) return true;
    return hasPathSum(root.left, sum - root.val) ||  hasPathSum(root.right, sum - root.val) ;
};
```

### 解法二

当我们访问到叶子节点时，如果之前访问的节点值总和 + 当前叶子节点 val == sum, 则返回true，否则返回false

时间复杂度：O(N) 空间复杂度，评价情况，O(log(N)) ， 和解法一一致

### 代码

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
   return dps (root, 0, sum)
};

function dps (root, cur, sum) {
    if(!root) return false
    cur = root.val + cur
    if(cur == sum && root.left == null && root.right == null) return true;
    else {
        return dps(root.left, cur, sum) || dps(root.right, cur, sum)
    }
}

```

