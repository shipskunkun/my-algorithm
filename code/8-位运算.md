### 8-位运算

```
1. 268. 缺失数字
2. 136. 只出现一次的数字
```

​	





#### [268. 缺失数字](https://leetcode-cn.com/problems/missing-number/)

难度简单307

给定一个包含 `0, 1, 2, ..., n` 中 *n* 个数的序列，找出 0 .. *n* 中没有出现在序列中的那个数。

**示例 1:**

```
输入: [3,0,1]
输出: 2
```

**示例 2:**

```
输入: [9,6,4,2,3,5,7,0,1]
输出: 8
```

### 思路

1. 排序遍历

2. 位运算

   ​	任何数与0 异或，是自己

   ​	与自己异或，是 0

3. 和求差值

### 代码

1. 排序

   ```js
   var missingNumber = function(nums) {
       let arr = nums.sort((a,b)=> a-b);
       for(let i = 0; i <= arr.length; i++) {
           if(nums[i] !== i) {
               return i
           }
       }
   };
   ```

3. 异或

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
    let result;
    for(let i = 0; i <= nums.length; i++)  {
        result = result ^ (nums[i] ^ i)
    }
    return result
};
```

4. 求差值

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var missingNumber = function(nums) {
       let result = nums.length * (nums.length + 1) / 2;
       let sum = nums.reduce((sum, cur, index, arr)=>{
           return sum + cur
       }, 0)
       return result - sum;
   };
   ```

   

### 2. [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

```
示例 1:
输入: [2,2,1]
输出: 1

示例 2:
输入: [4,1,2,1,2]
输出: 4
```

### 思路

异或

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    let result
    for(let i = 0; i < nums.length; i++) {
        result = result ^ nums[i]
    }
    return result
};
```

