### 11-20道算法题

11.	最小的k个数
12. 数组中的第K个最大元素
13. 删除链表的节点
14. 两个链表的第一个公共节点
15. 反转链表
16. 股票的最大利润
17. 把数组排成最小的数
18. 合并两个排序的链表
19. 重建二叉树






### 11. 最小的k个数
输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

 

示例 1：
	
	输入：arr = [3,2,1], k = 2
	输出：[1,2] 或者 [2,1]
	示例 2：
	
	输入：arr = [0,1,2,1], k = 1
	输出：[0]


### 解题思路
思路：快排, 先找到 k 的位置

### 代码

```javascript
/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number[]}
 * 
 * 
 */

var getLeastNumbers = function(arr, k) {
    var cur = arr[0];
    var left = [];
    var right = [];
    for(var i = 1; i < arr.length; i++) {
        if(arr[i] < cur) {
            left.push(arr[i])
        }else {
            right.push(arr[i])
        }
    }
    if(left.length == k ) return left
    else if(left.length > k) {
        return getLeastNumbers(left, k)
    }else {
        return left.concat(cur, getLeastNumbers(right, k - left.length - 1))
    }
};
```

### 12.数组中的第K个最大元素

在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

示例 1:

	输入: [3,2,1,5,6,4] 和 k = 2
	输出: 5
	示例 2:
	
	输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
	输出: 4

### 解题思路

将数组倒序，用数组第一个数为基准，左边的都比arr[0] 大，右边的都比 arr[0] 小
如果 left.length + 1 == k, 说明 基准是第k大的数
如果 left.length >= k， 说明第k大的数在 left 中
否则，在right中

### 代码

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 * 倒序排序
 */
var findKthLargest = function(arr, k) {
    var cur = arr[0];
    var left = [];
    var right = [];
    for(var i = 1; i < arr.length; i++) {
        if(arr[i] > cur) {
            left.push(arr[i])
        }else {
            right.push(arr[i])
        }
    }
    if(left.length + 1 == k ) { return cur}
    else if(left.length >= k ) {
        return findKthLargest(left, k)
    }
    else {
        return findKthLargest(right, k - left.length - 1)
    }
};
```


### 13. 删除链表的节点
给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

示例 1:

	输入: head = [4,5,1,9], val = 5
	输出: [4,1,9]
	解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
示例 2:

	输入: head = [4,5,1,9], val = 1
	输出: [4,5,9]
	解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.

### 解题思路

时间复杂度 O(N) 空间复杂度O(1)

### 代码

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
var deleteNode = function(head, val) {
    let p1 =  head;
    let p2 = head.next;
    if(head.val == val) {
        head = head.next;
        return head
    }
    else {
        while(p2) {
            if(p2.val == val) {
                p1.next = p2.next
                return head
            }
            else {
                p1 = p1.next;
                p2 = p2.next;
            }
        }
    }
};
```
### 14. 两个链表的第一个公共节点

	输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
	输出：Reference of the node with value = 8

输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

	输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
	输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
 

注意：

	如果两个链表没有交点，返回 null.
	在返回结果后，两个链表仍须保持原有的结构。
	可假定整个链表结构中没有循环。
	程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。
	本题与主站 160 题相同：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/








### 15.反转链表

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

 

示例:

	输入: 1->2->3->4->5->NULL
	输出: 5->4->3->2->1->NULL
 

限制：

	0 <= 节点个数 <= 5000

### 解题思路
使用双指针，当前指针cur, 它的前指针 pre	
保存cur.next	
每次 让cur指针的next指向pre		
局部反转完成后，pre和cur向前移动一个位置		
循环上述过程，直至pre到达链表尾部	

### 代码
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    let pre = null;
    let cur = head;
    let t = null;
    while(cur) {
        t = cur.next;
        cur.next = pre;
        pre = cur;
        cur = t; 
    }
    return pre;
};
```



### 16. 股票的最大利润

假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？


示例 1:

	输入: [7,1,5,3,6,4]
	输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
示例 2:

	输入: [7,6,4,3,1]
	输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。


### 17. 把数组排成最小的数

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

 

示例 1:

	输入: [10,2]
	输出: "102"
示例 2:

	输入: [3,30,34,5,9]
	输出: "3033459"
 

提示:

	0 < nums.length <= 100

### 解题思路
此题求拼接起来的 “最小数字” ，本质上是一个排序问题。	
数组sort 接受自定义函数，这个函数用来判断，两个数如何排序更小	
若拼接字符串 x + y > y + x ，则 x > y ；反之，x < y ；	
比如[3, 30], 303 < 330, 所以，使用排序规则后排序后变成，[30, 3]	

### 代码

```javascript
/**
 * @param {number[]} nums
 * @return {string}
 */

function minus(a, b) {
    a = "" + a;
    b = "" + b;
    return (a + b) - (b + a);
}
var minNumber = function(nums) {
    return nums.sort(minus).join("")
};
```


### 使用sort

```javascript
/**
 * @param {number[]} nums
 * @return {string}
 */

function minus(a, b) {
    a = "" + a;
    b = "" + b;
    return (a + b) - (b + a);
}
var minNumber = function(nums) {
    return nums.sort(minus).join("")
};
```


### 18. 合并两个排序的链表

输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

示例1：

	输入：1->2->4, 1->3->4
	输出：1->1->2->3->4->4

### 解题思路
思路很简单，新建一个新链表，比较l1, l2 当前位置的val, 谁小插入谁  
注意点，边际情况，当 l1 l2 均为空的时候，注意使用head 保存头结点   
注意，每次新链表节点，也要移动到当前位置	
注意l1或者l2 有一个遍历完的情况	

时间复杂度 O(M+N)： M, NM,N 分别为链表 l1、l2长度

空间复杂度 O(1)

### 代码

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    if(l1 == null && l2 == null) return null;
    let p = new ListNode();
    let head = p;
    while(l1 && l2) {
        if(l1.val < l2.val) {
            p.next = l1;
            l1 = l1.next;
        }else {
            p.next = l2;
            l2 = l2.next;
        }
        p = p.next;
    }
    if(l1) {
        p.next = l1;
    }
    if(l2) {
        p.next = l2;
    }
    return head.next;
};
```

### 19. 重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

 

例如，给出

	前序遍历 preorder = [3,9,20,15,7]
	中序遍历 inorder = [9,3,15,20,7]


// i有两个含义，一个是根节点在中序遍历结果中的下标，另一个是当前左子树的节点个数

### 错误解法1 
原因：边界情况错误

```javascript
var buildTree = function(preorder, inorder) {
    if(!preorder.length && !inorder.length) return null
    
    let val = preorder[0];
    let root = new TreeNode(val);
    let i = inorder.indexOf(val);

    root.left = buildTree(preorder.slice(1, 1+i), inorder.slice(0, i));

    root.right = buildTree(preorder.slice(i+1), inorder.slice(i+1));
    return root;
};
```


### 解题思路
前序遍历，第一个值肯定是根节点		
在中序遍历中，寻找根节点位置，= 当前左子树的节点个数  
递归建立该节点的左孩子，右孩子  
注意边界情况  

时间复杂度：O(n)。对于每个节点都有创建过程以及根据左右子树重建过程。		
空间复杂度：O(n)。存储整棵树的开销。

### 代码

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {

    if(!preorder.length || !inorder.length) return null

    let val = preorder[0];
    let root = new TreeNode(val);
    let i = inorder.indexOf(val);

    root.left = buildTree(preorder.slice(1, 1+i), inorder.slice(0, i));

    root.right = buildTree(preorder.slice(i+1), inorder.slice(i+1));
    return root;
};
```






