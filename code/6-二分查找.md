### 6-二分查找


	1. 367. 有效的完全平方数
	2. 69. x 的平方根
	3. 70. 面试题16. 数值的整数次方
	4. 704. 二分查找
	5. 50. Pow(x, n)

### 367. 有效的完全平方数

给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。

说明：不要使用任何内置的库函数，如  sqrt。

	示例 1：
	
	输入：16
	输出：True
	示例 2：
	
	输入：14
	输出：False

### 解题思路

一个非整数的平方数小于 2/n + 1，所以可以利用二分查找在 [0, 2/n+1] 范围内查找



### 代码

```javascript
/**
 * @param {number} num
 * @return {boolean}
 * 首先，二分查找， high n/2 +1
 */
 
var isPerfectSquare = function(num) {
    let low = 0;
    let high = parseInt(num/2) + 1;
    while(low <= high) {
        let mid =  parseInt((low +high)/2);
        if(mid * mid == num) {
            return true
        }
        if(mid * mid > num) {
            high = mid - 1;
        }
        else if(mid * mid < num) {
            low = mid + 1;
        }
    }
    return false
};
```



### 69. x 的平方根


实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

	示例 1:
	
	输入: 4
	输出: 2
	示例 2:
	
	输入: 8
	输出: 2
	说明: 8 的平方根是 2.82842..., 
	     由于返回类型是整数，小数部分将被舍去。


### 错误代码：

9 死循环。

``` javascript
/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function(x) {
    let low = 0;
    let high = x/2 + 1;
    while(low <  high) {
        let mid = Math.floor((low + high) / 2);
        if(mid * mid <= x && (mid + 1) * (mid + 1) > x ) {
            return mid
        }
        else if(mid * mid < x) {
            low = mid + 1;
        }
        else {
            high = mid - 1;
        }
    }
};
```


### 解题思路

第一次写 终止条件是 low < high, 在 x = 9 的时候死循环了

### 代码

```javascript
/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function(x) {
    let low = 0;
    let high = x;
    while(low <=  high) {
        let mid = Math.floor((low + high) / 2);
        if(mid * mid <= x && (mid + 1) * (mid + 1) > x ) {
            return mid
        }
        else if(mid * mid < x) {
            low = mid + 1;
        }
        else {
            high = mid - 1;
        }
    }
};
```

### 70. 面试题16. 数值的整数次方

实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

 

示例 1:

	输入: 2.00000, 10
	输出: 1024.00000
示例 2:

	输入: 2.10000, 3
	输出: 9.26100
示例 3:

	输入: 2.00000, -2
	输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25

### 错误解法：

哪里错了？

``` javascript
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
    if(n < 0) return  1/ myPow(x, -n);
    if(n == 0) return 1;
    if(n ^ 1 == 1 ) {
    		// 超时这样写
        return myPow(x, n/2) * myPow(x, n/2)
    }
    if(n ^ 1 == 0) {
        let y = myPow(x, (n-1)/2);
        return y * y * x;
    }
};
```
妈的，位运算不支持？


### 解题思路
时间复杂度是 O(logN)；由于采用递归结构，空间复杂度是 O(logN)。

### 代码

```javascript
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
    if(n < 0) return  1/myPow(x, -n);
    if(n == 0) return 1;
    if(n % 2 == 0 ) {
        let y = myPow(x, n/2);
        return y * y;
    }
    if(n % 2 == 1) {
        let y = myPow(x, (n-1)/2);
        return y * y * x;
    }
};
```

### 704. 二分查找

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。


示例 1:

	输入: nums = [-1,0,3,5,9,12], target = 9
	输出: 4
	解释: 9 出现在 nums 中并且下标为 4

​	

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let low = 0;
    let high = nums.length - 1;
    if(high == -1) return -1;
    while(low <= high) {
        let mid = low + parseInt((high - low)/2);
        if(nums[mid] == target) {
            return mid
        }
        else if( nums[mid] < target) {
            low = mid + 1
        }
        else if( nums[mid] > target) {
            high = mid - 1
        }
    }
    return -1
};
```

时间复杂度，O(logn)

空间复杂度，	

### 50. Pow(x, n)
实现 pow(x, n) ，即计算 x 的 n 次幂函数。

	示例 1:
	
	输入: 2.00000, 10
	输出: 1024.00000	



递归可以理解为，自己调用自己，一般需要存储上次计算的值

迭代可以理解为，一步步逼近结果值



### 方法1，递归

```js
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
    if(n < 0)  return 1/myPow(x, -n)
    if(n == 0)  return 1
    if(n == 1)  return x
    while(n > 1) {
        if(n%2 == 0) {
            return myPow(x * x, n/2)
        }
        else if(n%2 == 1) {
            return x * myPow(x * x, (n-1)/2)
        }
    }
};
```

递归的次数和深度都是log2 n,每次所需要的辅助空间都是常数级别的：

时间复杂度，很好理解，是O(logn)
空间复杂度，O(log2 n)

比如 fn(x, 8)，需要保存的， fn(x, 4)   fn(x, 2)  fn(x, 1)

### 方法2， 迭代

一步步逼近，但是没有自己调用自己，我们不断求的是 x的乘积

比如，fn(x, 9)  =>  fn(x, 8) *  num =>  fn(x * x = y , 4) *num  =>   fn(y * y, 2)

```js
var myPow = function(x, n) {
    if(n < 0)  return 1/myPow(x, -n)
    if(n == 0)  return 1
    if(n == 1)  return x
    let result = 1;
    while(n > 1) {
        if(n%2 == 1) {
            n = n - 1;
            result = result * x;
        }
        x = x * x;
        n = n/2;
    }
    result = result  * x;
    return result;
};
```

循环的基本次数是log2 n，所以:时间复杂度是O(log2 n);
由于辅助空间是常数级别的所以：空间复杂度是O(1);

