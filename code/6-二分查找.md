### 6-二分查找


	1. 367. 有效的完全平方数
	2. 69. x 的平方根
	3. 70. 面试题16. 数值的整数次方
	4. 704. 二分查找
	5. 50. Pow(x, n)
	6. 153. 寻找旋转排序数组中的最小值
	7. 33.搜索旋转排序数组

### 367. 有效的完全平方数

给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。

说明：不要使用任何内置的库函数，如  sqrt。

	示例 1：
	
	输入：16
	输出：True
	示例 2：
	
	输入：14
	输出：False

### 解题思路

一个非整数的平方数小于 2/n + 1，所以可以利用二分查找在 [0, 2/n+1] 范围内查找



### 代码

```javascript
/**
 * @param {number} num
 * @return {boolean}
 * 首先，二分查找， high n/2 +1
 */
 
var isPerfectSquare = function(num) {
    let low = 0;
    let high = parseInt(num/2) + 1;
    while(low <= high) {
        let mid =  parseInt((low +high)/2);
        if(mid * mid == num) {
            return true
        }
        if(mid * mid > num) {
            high = mid - 1;
        }
        else if(mid * mid < num) {
            low = mid + 1;
        }
    }
    return false
};
```



### 69. x 的平方根


实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

	示例 1:
	
	输入: 4
	输出: 2
	示例 2:
	
	输入: 8
	输出: 2
	说明: 8 的平方根是 2.82842..., 
	     由于返回类型是整数，小数部分将被舍去。


### 错误代码：

9 死循环。

``` javascript
/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function(x) {
    let low = 0;
    let high = x/2 + 1;
    while(low <  high) {
        let mid = Math.floor((low + high) / 2);
        if(mid * mid <= x && (mid + 1) * (mid + 1) > x ) {
            return mid
        }
        else if(mid * mid < x) {
            low = mid + 1;
        }
        else {
            high = mid - 1;
        }
    }
};
```


### 解题思路

第一次写 终止条件是 low < high, 在 x = 9 的时候死循环了

### 代码

```javascript
/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function(x) {
    let low = 0;
    let high = x;
    while(low <=  high) {
        let mid = Math.floor((low + high) / 2);
        if(mid * mid <= x && (mid + 1) * (mid + 1) > x ) {
            return mid
        }
        else if(mid * mid < x) {
            low = mid + 1;
        }
        else {
            high = mid - 1;
        }
    }
};
```

### 70. 面试题16. 数值的整数次方

实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

 

示例 1:

	输入: 2.00000, 10
	输出: 1024.00000
示例 2:

	输入: 2.10000, 3
	输出: 9.26100
示例 3:

	输入: 2.00000, -2
	输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25

### 错误解法：

哪里错了？

``` javascript
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
    if(n < 0) return  1/ myPow(x, -n);
    if(n == 0) return 1;
    if(n ^ 1 == 1 ) {
    		// 超时这样写
        return myPow(x, n/2) * myPow(x, n/2)
    }
    if(n ^ 1 == 0) {
        let y = myPow(x, (n-1)/2);
        return y * y * x;
    }
};
```
妈的，位运算不支持？


### 解题思路
时间复杂度是 O(logN)；由于采用递归结构，空间复杂度是 O(logN)。

### 代码

```javascript
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
    if(n < 0) return  1/myPow(x, -n);
    if(n == 0) return 1;
    if(n % 2 == 0 ) {
        let y = myPow(x, n/2);
        return y * y;
    }
    if(n % 2 == 1) {
        let y = myPow(x, (n-1)/2);
        return y * y * x;
    }
};
```

### 704. 二分查找

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。


示例 1:

	输入: nums = [-1,0,3,5,9,12], target = 9
	输出: 4
	解释: 9 出现在 nums 中并且下标为 4

​	

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let low = 0;
    let high = nums.length - 1;
    if(high == -1) return -1;
    while(low <= high) {
        let mid = low + parseInt((high - low)/2);
        if(nums[mid] == target) {
            return mid
        }
        else if( nums[mid] < target) {
            low = mid + 1
        }
        else if( nums[mid] > target) {
            high = mid - 1
        }
    }
    return -1
};
```

时间复杂度，O(logn)

空间复杂度，	

### 50. Pow(x, n)
实现 pow(x, n) ，即计算 x 的 n 次幂函数。

	示例 1:
	
	输入: 2.00000, 10
	输出: 1024.00000	



递归可以理解为，自己调用自己，一般需要存储上次计算的值

迭代可以理解为，一步步逼近结果值



### 方法1，递归

```js
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
    if(n < 0)  return 1/myPow(x, -n)
    if(n == 0)  return 1
    if(n == 1)  return x
    while(n > 1) {
        if(n%2 == 0) {
            return myPow(x * x, n/2)
        }
        else if(n%2 == 1) {
            return x * myPow(x * x, (n-1)/2)
        }
    }
};
```

递归的次数和深度都是log2 n,每次所需要的辅助空间都是常数级别的：

时间复杂度，很好理解，是O(logn)
空间复杂度，O(log2 n)

比如 fn(x, 8)，需要保存的， fn(x, 4)   fn(x, 2)  fn(x, 1)

### 方法2， 迭代

一步步逼近，但是没有自己调用自己，我们不断求的是 x的乘积

比如，fn(x, 9)  =>  fn(x, 8) *  num =>  fn(x * x = y , 4) *num  =>   fn(y * y, 2)

```js
var myPow = function(x, n) {
    if(n < 0)  return 1/myPow(x, -n)
    if(n == 0)  return 1
    if(n == 1)  return x
    let result = 1;
    while(n > 1) {
        if(n%2 == 1) {
            n = n - 1;
            result = result * x;
        }
        x = x * x;
        n = n/2;
    }
    result = result  * x;
    return result;
};
```

循环的基本次数是log2 n，所以:时间复杂度是O(log2 n);
由于辅助空间是常数级别的所以：空间复杂度是O(1);



### 6. [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

难度中等250

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。

请找出其中最小的元素。

你可以假设数组中不存在重复元素。

**示例 1:**

```
输入: [3,4,5,1,2]
输出: 1
```

**示例 2:**

```
输入: [4,5,6,7,0,1,2]
输出: 0
```

### 思路

旋转数组，我还没搞明白

你可以把数组理解成一个圆桌，[1,2,3,4,5]  ，已3为圆心旋转，[3,4,5,1,2]



方法一：顺序遍历，常规解法，时间复杂度为O(n)（这里就不放代码了，有兴趣的朋友可以看看我写的本题的进阶题的题解，里面有该解法的代码：寻找旋转排序数组中的最小值 II）。
方法二：面试官期待的解法，二分法，时间复杂度为O(logn)。一般来说如果题目要求在排序的数组（或者部分排序的数组）中查找一个数字，或者统计一个数字出现的次数时，可以尝试二分法。

### 我的思路：

找变化点，变化点的特点： 左边值 > 变化点， 右边值 < 变化点

找变化点的过程是二分查找，找到 mid， 如果数组0 < mid ，说明左边在升序，我们在mid 右边找变化点

如果数组0 > mid，说明左边在降序，我们在mid 左边找变化点

### 第一次错误

错误原因：

终止查找的条件不对，要注意，只旋转了一次，我们只要确定，数组 0 -mid 是升序还是降序就好了

```
所有变化点左侧元素 > 数组第一个元素

所有变化点右侧元素 < 数组第一个元素
```

### 第二次错误

[1,2] 死循环

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function(nums) {
    if(nums.length < 1) return null;
    if(nums.length == 1) return nums[0];
    let low = 0;
    let high = nums.length - 1;
    while(low <= high) {
        let mid = low + parseInt((high - low) / 2);
        if(nums[mid - 1] > nums[mid]) {
            return nums[mid]
        }
        // 说明 0 - mid 在升序，在右边找
        else if(nums[0] < nums[mid] ) {
            low = mid + 1
        }
        // 说明肯定有个节点在下降，在左边找
        else if(nums[0] > nums[mid]) {
            high = mid
        }
    }
};
```

### 第四次

[1, 2] 还是死循环，因为 num[0] == mid 是可能的

只有 num[length - 1] 才保证不会死循环

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function(nums) {
    if(nums.length < 1) return null;
    if(nums.length == 1) return nums[0];
    let low = 0;
    let high = nums.length - 1;
    let min = nums[0];
    while(low < high) {
        let mid = low + parseInt((high - low) / 2);
        // 说明 0 - mid 在升序，在右边找，而且肯定不包括 mid
        if(min < nums[mid]  ) {
            low = mid + 1
        }
        // 说明 0 - mid 中有下降的, 在左边找，可能包括 mid
        else if(min > nums[mid]) {
            high = mid
        }
    }
    return nums[low]
};
```



### 第五次终于对了

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function(nums) {
    if(nums.length < 1) return null;
    if(nums.length == 1) return nums[0];
    let low = 0;
    let high = nums.length - 1;
    let max = nums[high];
    while(low < high) {
        let mid = low + parseInt((high - low) / 2);
        // 说明 mid - high 在升序，在左边找，可能包括mid
        if(nums[mid] < max  ) {
            high = mid
        }
        // 说明 mid - high 在降序, 在右边找，而且肯定不包括 mid
        else if(nums[mid] > max) {
            low = mid + 1
        }
    }
    return nums[low]
};
```



### 7. [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。

示例 1:

```
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
```


示例 2:

```
输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```

### 思路

这里，如果还是用 mid ，判断 mid 和 target 会很麻烦，转成，判断左边升序还是降序

我们只有在有序序列中，才能查找值

这一点很重要！！！我们要先找到有序序列段

### 错误一

死循环

```
 nums = [4,5,6,7,0,1,2], target = 3
```

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let low = 0;
    let high = nums.length - 1;

    if(nums.length == 0) return -1
    if(nums.length == 1) return nums[0] == target ? 0 : -1;
    
    while(low < high) {
        let mid = parseInt((high + low)/2);
        if(nums[mid] == target) {
            return mid
        }
        // 判断右边是升序
        if(nums[mid] < nums[nums.length - 1] ) {
            // 如果查找的值在升序中，
            if(nums[mid]< target && target <= nums[nums.length - 1]) {
                low = mid + 1
            }
            else {
                high = mid
            }
        }
        //说明左边在升序
        else if(nums[0] < nums[mid]) {
            // 如果查找的值在升序中
            if( nums[0] <= target && target < nums[mid]) {
                high = mid - 1
            }
            else {
                low = mid
            }
        }
    }
    return -1

};
```

### 错误2

死循环

[3,1]  0

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let low = 0;
    let high = nums.length - 1;

    if(nums.length == 0) return -1
    if(nums.length == 1) return nums[0] == target ? 0 : -1;
    
    while(low <= high) {
        let mid = parseInt((high + low)/2);
        
        if(nums[mid] == target) {
            return mid
        }
        // 判断右边是升序
        if(nums[mid] < nums[nums.length - 1] ) {
            // 如果查找的值在升序中，
            if(nums[mid]< target && target <= nums[nums.length - 1]) {
                low = mid + 1
            }
            else {
                high = mid - 1
            }
        }
        //说明左边在升序
        else if(nums[0] < nums[mid]) {
            // 如果查找的值在升序中
            if( nums[0] <= target && target < nums[mid]) {
                high = mid - 1
            }
            else {
                low = mid + 1
            }
        }
    }
    return -1

};
```

### 改

==

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let low = 0;
    let high = nums.length - 1;

    if(nums.length == 0) return -1
    if(nums.length == 1) return nums[0] == target ? 0 : -1;
    
    while(low <= high) {
        let mid = parseInt((high + low)/2);
        
        if(nums[mid] == target) {
            return mid
        }
        // 判断右边是升序
        if(nums[mid] <= nums[nums.length - 1] ) {
            // 如果查找的值在升序中，
            if(nums[mid]< target && target <= nums[nums.length - 1]) {
                low = mid + 1
            }
            else {
                high = mid - 1
            }
        }
        //说明左边在升序
        else if(nums[0] <= nums[mid]) {
            // 如果查找的值在升序中
            if( nums[0] <= target && target < nums[mid]) {
                high = mid - 1
            }
            else {
                low = mid + 1
            }
        }
    }
    return -1

};
```

