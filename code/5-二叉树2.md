### 5. 二叉树2

```
1. 236. 二叉树的最近公共祖先
2. 108. 将有序数组转换为二叉搜索树
3. 450. 删除二叉搜索树中的节点
4. 129. 求根到叶子节点数字之和
5. 257. 二叉树的所有路径
6. 404. 左叶子之和
7. 110. 平衡二叉树
8. 101. 对称二叉树
9. 100. 相同的树
10. 105. 从前序与中序遍历序列构造二叉树
11. 
```

#### 1.  [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

难度中等728

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png)

 

**示例 1:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

###  思路

这题我记得之前做过，如果两个节点一个是根，直接返回当前节点

如果两个节点，分别在左右子树上，返回根

否则，再在左右子树上查找



### 第一个版本

错误原因：如果在左子树上找q，在右子树上找 p ，不符合要求

[1,2,3]
3
2

问题：如何得出 q、p 分别在二叉树的两侧

结论：都在左子树上找即可。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if(root == null) return false;
    if(root.val == p.val) return p;
    if(root.val == q.val) return q;
    
    let findL = findNode(root.left, p);
    let findR = findNode(root.right, q);
    if(findL && findR) return root;
    else if(findL) return lowestCommonAncestor(root.left, p, q);
    else if(findR) return lowestCommonAncestor(root.left, p, q);

};

function findNode(root, node) {
    if(root == null) return false;
    if(root.val == node.val) return true;
    return findNode(root.left, node) || findNode(root.right, node);
}
```

### 正确

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if(root == null) return false;
    if(root.val == p.val) return p;
    if(root.val == q.val) return q;

    let findP = findNode(root.left, p);
    let findQ = findNode(root.left, q);

    
    if(findP && findQ) return lowestCommonAncestor(root.left, p, q); 
    else if(findP || findQ) return root;
    else return lowestCommonAncestor(root.right, p, q);
};

function findNode(root, node) {
    if(root == null) return false;
    if(root.val == node.val) return true;
    return findNode(root.left, node) || findNode(root.right, node);
}
```



###  2. [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例:

给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
    -3   9
     /   /
    -10  5


### 我的思路

首先用二分法，确定根，然后递归确定左孩子和右孩子？

### 代码

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var sortedArrayToBST = function(nums) {
    if(!nums.length) return null;
    let mid = parseInt(nums.length / 2);
    let root = new TreeNode(nums[mid]);
    root.left = sortedArrayToBST(nums.slice(0, mid))
    root.right = sortedArrayToBST(nums.slice(mid+1, nums.length))
    return root;
};
```

#### 3. [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

难度中等277

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

1. 首先找到需要删除的节点；
2. 如果找到了，删除它。

**说明：** 要求算法时间复杂度为 O(h)，h 为树的高度。

**示例:**

```
root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。

一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。

    5
   / \
  4   6
 /     \
2       7

另一个正确答案是 [5,2,6,null,4,null,7]。

    5
   / \
  2   6
   \   \
    4   7
```

### 思路

二叉搜索树的特点：中序遍历是 递增的

如果是叶子节点，节点的父元素 left 或者 right 指向空，否则，左孩子中的最大值

或者右孩子中的最小值代替自己

然后删除节点。

感觉时间复杂度不止O(n) 啊

看看别人的



4. #### [129. 求根到叶子节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

   难度中等190

   给定一个二叉树，它的每个结点都存放一个 `0-9` 的数字，每条从根到叶子节点的路径都代表一个数字。

   例如，从根到叶子节点路径 `1->2->3` 代表数字 `123`。

   计算从根到叶子节点生成的所有数字之和。

   **说明:** 叶子节点是指没有子节点的节点。

   **示例 1:**

   ```
   输入: [1,2,3]
       1
      / \
     2   3
   输出: 25
   解释:
   从根到叶子节点路径 1->2 代表数字 12.
   从根到叶子节点路径 1->3 代表数字 13.
   因此，数字总和 = 12 + 13 = 25.
   ```

### 思路

叶子节点值 = 父节点值 * 10 + current.val

当且仅当节点是叶子节点时，结束计算，返回值是当前累计和

返回所有当前节点的左右孩子 和



卡在哪里？

第一遍写，哪里不对？

逻辑不通，瞎几把写，返回的是什么没搞清楚

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumNumbers = function(root) {
    return dfs(root, 0)
};

function dfs(root, sum) {
    if(root == null) return ;
    sum = sum *  10 + root.val;
    dfs(root.left, sum)
    dfs(root.right, sum)
    return sum;
}
```



### 第二遍

思路： 什么时候结束？当这个节点是叶子节点的时候，返回 累加值

否则 =  左边值 + 右边值

如果是空怎么办？返回 0

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumNumbers = function(root) {
    if(root == null) return 0;
    return dfs(root, 0);
};

function dfs(root, sum) {
    if(root == null) return 0;
    sum = sum *  10 + root.val;
    if(!root.left && !root.right ) return sum;
    return dfs(root.left, sum) + dfs(root.right, sum)
}
```



###  5. [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明: 叶子节点是指没有子节点的节点。

示例:

```
输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
```



### 思路

和上面一题有点像，但是不全一样

只有叶子节点才有路径，只有叶子节点，才把 path push 到 arr 中

### 代码

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {string[]}
 */
var binaryTreePaths = function(root) {
    let arr = [];
    if(root == null) return arr;
    let path = '';
    return dfs(root, path ,arr)
};

function dfs(root, path, arr) {
    if(root == null) return;
    path = path ? path + '->' + root.val : path + root.val ;
    if(!root.left && !root.right) {
        arr.push(path);
    }
    dfs(root.left, path, arr);
    dfs(root.right, path, arr);
    return arr;
}
```



### 6.  [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

计算给定二叉树的所有左叶子之和。

示例：

    	 3
      / \
      9  20
        /  \
       15   7
在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24

### 思路

左叶子的条件：？卡住在这里

首先，肯定是左边树上的 左叶子 + 右边树上的左叶子

如何判断当前节点是左叶子？ 

这是关键， 你是左孩子，可以让父元素告诉你，你是叶子元素，可以通过左右孩子是否为空判断

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumOfLeftLeaves = function(root) {
    let sum = 0;
    if(root == null) return sum;
    return dfs(root, 0, false);
};

function dfs(root, sum, isLeft) {
    if(!root) return 0;
    if(!root.left && !root.right && isLeft) {
        sum = sum + root.val;
        return sum;
    }
    return dfs(root.left, sum, true) + dfs(root.right, sum, false)
}
```



### . [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

```
 		3
   / \
  9  20
    /  \
   15   7
```

返回 true 。

### 思路

递归：

自己的左孩子h - 右孩子高度 < 1

然后 左孩子也是这样，右孩子也是这样

复杂度比较高



第二种：在求孩子高度的时候，一旦出现，左右孩子高度差 > 1 ，结束查找，深度遍历。

如何求当前节点的高度：

如果是空，0， 否则是左孩子，右孩子中，大的那一个 + 1。

Math.max(leftHeight, rightHeight) + 1。

官方的代码讲的很好。

### 思路一，递归代码

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
    if(!root) return true;
    let leftH = getHight(root.left);
    let rightH = getHight(root.right);
    return Math.abs(leftH - rightH) < 2 && isBalanced(root.left) && isBalanced(root.right)
};

function getHight(root) {
    if(!root) return 0;
    return Math.max(getHight(root.left),  getHight(root.right))  + 1
}
```

### 思路二，深度遍历，如果孩子不符合，停止递归，返回false

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
    return getHight(root) > -1
};

function getHight(root) {
    if(!root) return 0;
    let leftH = getHight(root.left);
    let rightH = getHight(root.right);
    if(leftH == -1 || rightH == -1 || Math.abs(leftH - rightH) > 1) {
        return -1;
    }
    else {
        return Math.max(leftH, rightH) + 1;
    }
}
```



### 8.  [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:

```
		1
   / \
  2   2
   \   \
   3    3
```



### 思路：



### 9. [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**示例 1:**

```
输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
```

**示例 2:**

```
输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
```

### 我的思路？

递归？每一层都比较，这样可以吗？ 比较根，不相等，直接返回

然后比较左孩子 和 右孩子

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {
    if(p == null && q == null) return true;
    if(p == null || q == null) return false;
    if(p.val != q.val) return false;
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
};
```



### 10. [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```


返回如下的二叉树：

    	3
     / \
      9  20
        /  \
       15   7
  ### 思路

先确定根节点，然后递归调用构造方法

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
    if(!preorder.length || !inorder.length) return null;
    let rootVal = preorder[0];
    let index = inorder.indexOf(rootVal);
    let root = new TreeNode(rootVal);
    root.left = buildTree(preorder.slice(1, 1+index), inorder.slice(0, index));
    root.right = buildTree(preorder.slice(index + 1), inorder.slice(index + 1));
    return  root;
};
```



### 11.  [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

难度中等391

给定一个二叉树，返回它的 *后序* 遍历。

**示例:**

```
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
```

### 递归

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    let arr = []
    dfs(root, arr)
    return arr
};

function dfs(root, arr) {
    if(!root) return
    root.left && dfs(root.left, arr)
    root.right && dfs(root.right, arr)
    root.val && arr.push(root.val)
}
```

