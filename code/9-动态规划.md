## 9-动态规划

	1. 青蛙跳台阶问题
	2. 斐波那契数列
	3. 三步问题
	4. 最大子序和
	5. 不同路径
	6. 120. 三角形最小路径和
	7. 零钱兑换
	8. 最小路径和  = 礼物的最大价值,  类型一样
	9. 198. 打家劫舍
	10. 300. 最长上升子序列
	


### 1. 青蛙跳台阶问题

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

	示例 1：
	
	输入：n = 2
	输出：2
	示例 2：
	
	输入：n = 7
	输出：21
	提示：
	
	0 <= n <= 100



### 解题思路
啥叫「自顶向下」？递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫「自顶向下」。

啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

注意取模，要在循环里面取

时间复杂度： O(n),计算 f(n)f(n) 需循环 nn 次，每轮循环内计算操作使用 O(1)O(1)  		
空间复杂度：O(n)

也有空间复杂度为 O(1)的解法

### 代码

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var numWays = function(n) {
    if(n <= 1) return 1;
    var arr = new Array( n + 1 );
    arr[0] = 1;
    arr[1] = 1;
    for(var i = 2; i< n+1; i++) {
        arr[i] = (arr[i-1] + arr[i-2])%1000000007
    }
    return arr[n]
};
```

### 2. 斐波那契数列

写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

 

	示例 1：
	
	输入：n = 2
	输出：1
	示例 2：
	
	输入：n = 5
	输出：5


​	
	提示：
	
	0 <= n <= 100



### 解题思路
啥叫「自顶向下」？递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫「自顶向下」。

啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

注意取模，要在循环里面取

时间复杂度： O(n)		
空间复杂度： O(1)

### 代码

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var fib = function(n) {
    var dp = [];
    dp[0] = 0;
    dp[1] = 1;
    if(n <= 1) { return dp[n] }
    for(var i = 2; i <= n; i++){
        dp[2] = (dp[0] + dp[1])%1000000007;
        dp[0] = dp[1];
        dp[1] = dp[2];
    }
    return dp[2];
};
```



### 3. 三步问题
 三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。

示例1:

	 输入：n = 3 
	 输出：4
 说明: 有四种走法
示例2:

	 输入：n = 5
	 输出：13
提示:

n范围在[1, 1000000]之间

### 解题思路

f(n)=f(n-1)+f(n-2)+f(n-3)  
理解，f(3) = 4   
确实有4种情况  
1，1，1  
1，2  
2，1  
3

### 代码

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var waysToStep = function(n) {
    let arr = [1, 1, 2, 4];
    for(let i = 4; i <= n; i++) {
        arr[i] = (arr[i - 3] + arr[i - 2] + arr[i - 1])%1000000007;
    }
    return arr[n];
};
```


### 4.最大子序和


给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

	输入: [-2,1,-3,4,-1,2,1,-5,4],
	输出: 6
	解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
进阶:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

### 解题思路
理解dp[i]含义

如果设第i个状态(dp[i])代表前i个数字组成的连续的最大子段和，并不 能根据dp[i-1]、dp[i-2]、...、dp[0]推导出dp[i]。

如[-2,1,-3,4,-1,2,1,-5,4],
dp[0] = -2, dp[1] = 1, dp[2] = 1, 

两者不相邻，故无法构成连续的子数组，之间无内在联系，故无法进行推导。

为了让第i个状态的最优解与第i-1个状态的最优解产生直接联系.
让dp[i] 为以第i个数字结尾的最大子段和。由于以第i-1个数字 结尾的最大子段和(dp[i-1])与nums[i]相邻:

if(dp[i-1] > 0) dp[i] = dp[i-1] + nums[i]  
else dp[i] = nums[i]


### 代码

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    let max = nums[0];
    let dp = [nums[0]];
    for(let i = 1; i < nums.length; i++) {
        dp[i] =  Math.max(dp[i - 1] +  nums[i], nums[i]);
        if(dp[i] > max) {
            max = dp[i]
        }
    }
    return max;
};
```


### 5.不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

例如，上图是一个7 x 3 的网格。有多少可能的路径？

 

	示例 1:
	
	输入: m = 3, n = 2
	输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
示例 2:

	输入: m = 7, n = 3
	输出: 28


提示：

1 <= m, n <= 100
题目数据保证答案小于等于 2 * 10 ^ 9

### 解题思路


一个位置在 i 行 j 列的元素，要么是从它上面走过来的，要么是从左面走过来的

arr[i][j] = arr[i - 1][j] + arr[i][j - 1]

注意二维数组的初始化，快忘了都

### 代码

```javascript
var uniquePaths = function(m, n) {
    let arr = new Array(m);
    for(let i = 0; i < m; i++) {
        arr[i] = new Array(n);
    }
    
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (i == 0 || j == 0 ) {
                arr[i][j] = 1
            } else  {
                arr[i][j] = arr[i - 1][j] + arr[i][j - 1]
            }
        }
    }
    return arr[m-1][n-1]
};
```

### 6. 三角形最小路径和
给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

例如，给定三角形：

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

说明：

如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。

### 解题思路

![pvr13x-m18.png](https://pic.leetcode-cn.com/0443b34e0d98eedce917d2c99b36a780f20f7cbbe4d8191fd4ef90423435d12f-pvr13x-m18.png)

### 方法一

改变原三角形内容，自顶向下  
注意，可能拿到 undefined的值，我们让它 =  无穷大

### 代码

```javascript
var minimumTotal = function(triangle) {
    for(var i = 1; i < triangle.length; i++) {
        for(let j = 0; j <= i; j++) {
            let a = triangle[i-1][j-1] == undefined ? Infinity : triangle[i-1][j-1];
            let b = triangle[i-1][j] == undefined ? Infinity : triangle[i-1][j];
            triangle[i][j] = Math.min(a ,b ) + triangle[i][j];
        }
    }
    return Math.min(...triangle[i - 1]);
};
```
### 方法二：

改变原三角形内容，自底向上。

### 代码

```javascript
var minimumTotal = function(triangle) {
    for(var i = triangle.length -2; i >= 0; i--) {
        for(let j = 0; j <= i; j++) {
            triangle[i][j] = Math.min(triangle[i+1][j] ,triangle[i+1][j+1] ) + triangle[i][j];
        }
    }
    return triangle[0][0];
};
```
### 方法三

使用O(n)的 额外空间，不改变原三角形内容，自底向上
注意，初始化，要多初始化一个值，最后一行的长度应该为  triangle.length + 1


### 代码

```javascript
var minimumTotal = function(triangle) {
    let  dp =  new Array(triangle.length + 1).fill(0);
    for(var i = triangle.length -  1; i >= 0; i-- ){
        for(var j= 0; j < triangle[i].length; j++) {
            dp[j] = Math.min(dp[j], dp[j+1])  + triangle[i][j]
        }
    }
    return dp[0]
};
```



### 7. 零钱兑换
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

 

示例 1:

	输入: coins = [1, 2, 5], amount = 11
	输出: 3 
	解释: 11 = 5 + 5 + 1
示例 2:

	输入: coins = [2], amount = 3
	输出: -1

### 解题思路

dp[i] 代表金额i的最优解，即最小使用张数

coins = [1, 2, 5], amount = 11

dp[11] = Math.min(dp[10] + 1， dp[9] + 1, dp[6] + 1)


### 代码

```
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
    var dp = new Array( amount + 1 ).fill( Infinity );
    dp[0] = 0;
    for (var i = 0; i <= amount; i++) {
        for(var coin of coins) {
            if(i  - coin < 0) continue;
            dp[i] = Math.min(dp[i], dp[i-coin] + 1)
        }
    }
   
    return dp[amount] == Infinity ? -1 : dp[amount];
};

```


### 8. 最小路径和

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例:

	输入:
	[
	  [1,3,1],
	  [1,5,1],
	  [4,2,1]
	]
	输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。

### 解题思路
状态定义：

设 dp 为大小 m×n 矩阵，其中 dp[i][j] 的值代表直到走到 (i,j) 的最小路径和。

转移方程：

题目要求，只能向右或向下走，换句话说，当前单元格 (i,j) 只能从左方单元格 (i-1,j)或上方单元格 (i,j-1) 走到，因此只需要考虑矩阵左边界和上边界。

走到当前单元格 (i,j)的最小路径和 == “从左方单元格 (i-1,j) 与 从上方单元格 (i,j-1) 走来的 两个最小路径和中较小的 ” + 当前单元格值 grid[i][j] 。

复杂度分析：  
时间复杂度 O(M×N) ： 遍历整个 grid 矩阵元素。  
空间复杂度 O(1) ： 直接修改原矩阵，不使用额外空间。


### 代码

```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function(grid) {
    let m = grid.length;
    let n = grid[0].length;
    
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if(i == 0 && j == 0) {
                grid[i][j] = grid[i][j]
            }
            else if(i == 0) {
                grid[i][j] = grid[i][j] + grid[i][j-1]
            }
            else if(j == 0) {
                grid[i][j] = grid[i][j] + grid[i-1][j]
            }
            else {
                grid[i][j] = grid[i][j] + Math.min(grid[i-1][j], grid[i][j-1])
            }
        }
    }
    return grid[m-1][n-1]
};
```

### 9. 打家劫舍


你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:

	输入: [1,2,3,1]
	输出: 4
	解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
	     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2:

	输入: [2,7,9,3,1]
	输出: 12
	解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
	     偷窃到的最高金额 = 2 + 9 + 1 = 12 。



### 解题思路
dp[n]表示，在当前位置 n 房屋可盗窃的最大值。

动态规划方程：dp[n] = MAX( dp[n-1], dp[n-2] + num )

由于不可以在相邻的房屋闯入，所以在当前位置 n 房屋可盗窃的最大值，要么就是 n-1 房屋可盗窃的最大值，要么就是 n-2 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值

如 [1,2,3,1]， 要么就是最后一个值，每间隔一个的累加和，2+1
要么就是倒数第二个值，每间隔一个的累加和， 1+3



### 代码

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
    let m = nums.length;
    let dp = [];
    dp[0] = 0;
    dp[1] =  nums[0];
    for(let i = 2; i <= m; i++) {
        dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1])
    }
    return dp[m]
};
```



### 10. 最长上升子序列


给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:

	输入: [10,9,2,5,3,7,101,18]
	输出: 4 
	解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
说明:

可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n2) 。
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?



### 解题思路

这题类似于53题，最大子序和，要搞清楚 dp[i] 代表什么

如果，dp[i] 代表前i个数字中，最长上升子序列长度，无法找出 dp[i] 和 dp[i+1] 的关系

dp[i]代表，以第i个数字为结尾的，最长上升子序列长度

![2.png](https://pic.leetcode-cn.com/ec850f6483a273ee9e7c449f19c3a3a596447dffbd2e020ef4a924ee1954bed3-2.png)

![3.png](https://pic.leetcode-cn.com/203bf29e975f683248da5ac4ee6690a2191399805a8b4096314d3192f26f36af-3.png)


### 代码

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
    if (nums.length < 2) {
        return nums.length;
    }
    let dp = new Array(nums.length).fill(1);
    let max_length = 1;
    for(let i = 1; i <  nums.length; i++) {
        for(let j = 0; j < i; j++) {
            if(nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1)
            }
        }
    }
    return Math.max(...dp);
};
```

