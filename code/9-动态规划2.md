9-动态规划

```
1. 152. 乘积最大子数组
2. 编辑距离
3. 674. 最长连续递增序列
4. 剑指 Offer 46. 把数字翻译成字符串
```

### 11. 152. 乘积最大子数组


给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

 

示例 1:

	输入: [2,3,-2,4]
	输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
示例 2:

	输入: [-2,0,-1]
	输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。



### 12. 编辑距离

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符  
删除一个字符  
替换一个字符  


示例 1：

	输入：word1 = "horse", word2 = "ros"
	输出：3
	解释：
	horse -> rorse (将 'h' 替换为 'r')
	rorse -> rose (删除 'r')
	rose -> ros (删除 'e')
示例 2：

	输入：word1 = "intention", word2 = "execution"
	输出：5
	解释：
	intention -> inention (删除 't')
	inention -> enention (将 'i' 替换为 'e')
	enention -> exention (将 'n' 替换为 'x')
	exention -> exection (将 'n' 替换为 'c')
	exection -> execution (插入 'u')

### 解题思路
动态规划：
dp[i][j] 代表 word1 到 i 位置转换成 word2 到 j 位置需要最少步数

所以，

当 word1[i] == word2[j]，dp[i][j] = dp[i-1][j-1]；

当 word1[i] != word2[j]，dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1

dp[i-1][j-1]到dp[i][j]需要进行替换操作



如何理解:

![img](https://pic.leetcode-cn.com/76574ab7ff2877d63b80a2d4f8496fab3c441065552edc562f62d5809e75e97e-Snipaste_2019-05-29_15-28-02.png)


word1 到 i 位置转换成 word2 到 j 位置

1. dp[i-1][j-1]到dp[i][j]需要进行替换操作
2. dp[i-1][j]到d[i][j]需要进行删除操作。
3. dp[i][j-1] 到d[i][j]需要进行添加操作。

horse => ros

ho => ro  相等，d[2][2] = d[1][1]

dp[i][j-1] 到d[i][j]需要进行添加操作。  
ho=> ros   插入"s", d[2][3] = d[2][2] + 1，插入了第j个元素

dp[i-1][j]到d[i][j]需要进行删除操作。  
hor => ro    删除"r", d[3][2] = d[2][2] + 1, 删除了第i个元素



### 代码

```javascript
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function(word1, word2) {
    let m = word1.length + 1;
    let n = word2.length + 1;
    let dp = new Array(m);
    for(let k = 0; k < m; k++) {
        dp[k] = new Array(n);
    }
    for(let i = 0; i < m; i++ ) {
        dp[i][0] =  i;
    }
    for(let j = 0; j < n; j++ ) {
        dp[0][j] =  j;
    }
    for(let i = 1; i < m; i++ ) {
        for(let j = 1; j < n; j++ ) {
            if(word1[i-1] == word2[j-1]) {
                dp[i][j] = dp[i-1][j-1]
            }
            else {
                dp[i][j] = 1 + Math.min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m-1][n-1]
};
```

### 3. [674. 最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

给定一个未经排序的整数数组，找到最长且连续的的递增序列，并返回该序列的长度。

示例 1:

```
输入: [1,3,5,4,7]
输出: 3
解释: 最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 
```


示例 2:

```
输入: [2,2,2,2,2]
输出: 1
解释: 最长连续递增序列是 [2], 长度为1。
```

### 思路

[参考这个人写的](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/solution/liang-chong-fang-fa-1pu-tong-de-bian-li-yi-bian-2d/)

方法1：首先处理特殊情况，即数组元素个数为0或1。定义两个变量，count：记录当前连续递增序列长度，res：记录最长续递增序列长度。
然后对数组进行遍历，每次比较当前元素和前一个元素的大小关系，大于count+1，小于count=1即可。

方法2：dp[i]含义：以nums[i]结尾的连续递增序列长度。
状态转移方程：dp[i] = dp[i-1] + 1 if nums[i] > nums[i-1] else 1

### 代码

方法1：普通的遍历

```
/**
 * @param {number[]} nums
 * @return {number}
 */
var findLengthOfLCIS = function(nums) {
    if(nums.length <= 1) return nums.length;
    let count = 1;
    let max = 1;
    for(let i = 1; i < nums.length; i++) {
        if(nums[i] > nums[i-1]) {
            count++;
            if(count > max) {
                max = count;
            }
        }
        else {
            count = 1
        }
    }
    return max;
};
```

方法2， 利用动态规划，dp[i] 是以 i 为结尾的，递增子序列长度

```
/**
 * @param {number[]} nums
 * @return {number}
 */
var findLengthOfLCIS = function(nums) {
    if(nums.length <= 1) return nums.length;
    let dp = new Array(nums.length).fill(1);
    for(let i = 1; i < nums.length; i++) {
        dp[i] = nums[i] > nums[i-1] ?  dp[i-1] + 1 : 1
    }
    return Math.max(...dp);
};
```



### 4. [剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

 示例 1:

```
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
```

