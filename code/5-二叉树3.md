### 5. 二叉树3

```
1. 剑指 Offer 27. 二叉树的镜像
2. 222.完全二叉树的节点个数
3. 剑指 Offer 32 - III. 从上到下打印二叉树 III
4. 543.二叉树的直径
```





### 1. [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

例如输入：

     		 4
       /   \
      2     7
     / \   / \
    1   3 6   9

镜像输出：

    	  4
      /   \
      7     2
     / \   / \
    9   6 3   1


### 思路

递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var mirrorTree = function(root) {
    dfs(root);
    return root
};

function dfs(root) {
    if(!root) return
    [root.left,  root.right] =  [root.right,  root.left];
    dfs(root.left);
    dfs(root.right);
}
```

### 2. [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

给出一个完全二叉树，求出该树的节点个数。

说明：

完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。

示例:

```
输入: 
    1
   / \
  2   3
 / \  /
4  5 6

输出: 6
```

### 思路

可以用深度遍历和层次遍历来做



### 代码

1. 深度遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var countNodes = function(root) {
    let arr = [];
    if(!root) return  arr.length
    dfs(root, arr)
    return  arr.length

};

function dfs(root, arr) {
    if(!root) return;
    arr.push(arr.val);
    dfs(root.left, arr);
    dfs(root.right, arr);
}
```

层次遍历

```js
var countNodes = function(root) {
    if(!root) return 0;
    let arr = [];
    let stack = [root];
    while(stack.length) {
        let cur = stack.pop();
        arr.push(cur);
        cur.left && stack.push(cur.left);
        cur.right && stack.push(cur.right);
    }
    return arr.length
};
```

### 二分法



### 3. [剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

 

例如:
给定二叉树: [3,9,20,null,null,15,7],

    		3
       / \
      9  20
        /  \
       15   7

返回其层次遍历结果：

```
[
  [3],
  [20,9],
  [15,7]
]
```

### 思路

没思路？！

看了别人写的，然后，改成 unshift 即可，偶数行

这样既可以倒序，也可以保证下一层，遍历左子树的孩子，快于右子树的孩子

### 代码

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    let arr = [];
    dfs(root, arr, 0)
    return arr;
};
function dfs(root, arr, layer) {
    if(!root) return
    if(!arr[layer]) arr[layer] = [];
    if(layer%2 == 1) {
         arr[layer].unshift(root.val);
    }
    else {
         arr[layer].push(root.val);
    }
    root.left && dfs(root.left, arr, layer + 1);
    root.right && dfs(root.right, arr, layer+1);
}
```



### 4. [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

 

示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。



### 错误

原因：自己认定一定会经过根节点，实际上，可能不会经过根节点

https://leetcode-cn.com/problems/diameter-of-binary-tree/solution/hot-100-9er-cha-shu-de-zhi-jing-python3-di-gui-ye-/

这个解答讲的挺好

[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]

测试不通过

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function(root) {
    if(!root) return 0;
    return getMaxHeight(root.left) + getMaxHeight(root.right)
};

function getMaxHeight(root) {
    if(!root) return 0;
    return Math.max(getMaxHeight(root.left) + 1, getMaxHeight(root.right) + 1)
}
```

### 改后

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function(root) {
    if(!root) return 0;
    return Math.max( getMaxHeight(root.left) + getMaxHeight(root.right),   diameterOfBinaryTree(root.left) , diameterOfBinaryTree(root.right)    )
};

function getMaxHeight(root) {
    if(!root) return 0;
    return Math.max(getMaxHeight(root.left) + 1, getMaxHeight(root.right) + 1)
}

```

