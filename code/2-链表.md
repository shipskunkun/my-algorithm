## 2. 链表


	1. 环形链表
	2. 环形链表 II  
	3. 删除中间节点
	4. 分割链表
	5. 移除重复节点
	6. 合并两个有序链表
	7. 删除链表的节点
	8. 反转链表
	9. 合并两个排序的链表
	10. 19. 删除链表的倒数第N个节点
	11. 链表中倒数第k个节点  




<hr>

### 1. 环形链表

给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

 

示例 1：

	输入：head = [3,2,0,-4], pos = 1
	输出：true
解释：链表中有一个环，其尾部连接到第二个节点。


### 解题思路
#### 方法一

利用set， set中的每一个值都是唯一的，遍历链表，如果 set中有节点曾经访问过，则证明有环  
时间复杂度：O(n)，对于含有 n 个元素的链表，我们访问每个元素最多一次。添加一个结点到哈希表中只需要花费 O(1) 的时间。   
空间复杂度：O(n)，空间取决于添加到哈希表中的元素数目，最多可以添加 n 个元素。  

### 代码
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    let s = new Set();

    while(head) {
        if(! s.has(head)) {
            s.add(head)
            head = head.next
        }
        else {
            return true
        }
    }
    return false
};
```



#### 方法二

快慢指针，设置快慢两个指针，遍历单链表，快指针一次走两步，慢指针一次走一步，如果单链表中存在环，则快慢指针终会指向同一个节点，否则直到快指针指向 null 时，快慢指针都不可能相遇

时间复杂度：O(n)， n 为链表中结点的总数。  
空间复杂度：O(1)，我们只使用了慢指针和快指针两个结点，所以空间复杂度为 O(1)。


### 代码

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    if(!head || !head.next) return false
    let slow = head;
    let fast = head;
    fast = fast.next.next;
    while(slow !== fast) {
        if(!fast || !fast.next) return false
        slow = slow.next;
        fast = fast.next.next;
    }
    return true;
};
```

### 2.环形链表 II


给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。

 

示例 1：

	输入：head = [3,2,0,-4], pos = 1
	输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：

	输入：head = [1,2], pos = 0
	输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个节点。


### 错误代码

错误提示： 时间超出，
错误原因： 不能让 fast 先走两步，把这个放到循环里面！



/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function(head) {
    if(!head || !head.next) return null
    let slow = head;
    let fast = head.next.next;
    while( slow != fast) {
        if(!fast || !fast.next) return null
        fast = fast.next.next;
        slow = slow.next;
    }
    fast = head;
    while(slow != fast) {
        fast = fast.next;
        slow = slow.next;
    }
    return slow
};



### 解题思路
#### 方法一

利用set， set中的每一个值都是唯一的，遍历链表，如果 set中有节点曾经访问过，立即返回改节点

时间复杂度：O(n)，对于含有 n 个元素的链表，我们访问每个元素最多一次。添加一个结点到哈希表中只需要花费 O(1) 的时间。   
空间复杂度：O(n)，空间取决于添加到哈希表中的元素数目，最多可以添加 n 个元素。  

#### 代码

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function(head) {
    let s = new Set();
    while(head) {
        if(!s.has(head)) {
            s.add(head)
            head =  head.next
        }
        else {
            return head
        }
    }
    return null
};
```

#### 方法二
快慢指针，设置快慢两个指针，遍历单链表，快指针一次走两步，慢指针一次走一步，如果单链表中存在环，则快慢指针终会指向同一个节点，否则直到快指针指向 null 时，快慢指针都不可能相遇

当他们相遇时，经过验证，此时从head 和 相遇节点，同步前行，能到达环节点

慢指针在环外路程，a
慢指针和快指针在环内路程，b
相遇节点到环节点路程，c

fast 路程是 slow 两倍
2*(a+b) =  a + b + c + b
a = c

时间复杂度：O(n)， n 为链表中结点的总数。  
空间复杂度：O(1)，我们只使用了慢指针和快指针两个结点，所以空间复杂度为 O(1)。

#### 代码

```javascript
var detectCycle = function(head) {
    if(!head || !head.next) return null
    let slow = head;
    let fast = head;
    while(fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if(slow == fast) {
            fast = head;
            while(slow != fast) {
                slow = slow.next;
                fast = fast.next;
            }
            return slow
        }
    }
    return null
};

```

### 3. 删除中间节点

实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。

 

示例：

	输入：单向链表a->b->c->d->e->f中的节点c
	结果：不返回任何数据，但该链表变为a->b->d->e->f

### 解题思路

删除该节点，又不给该节点的前指针，所以我们可以删除下一个节点，然后让此节点的值 = 下一个节点的值


### 代码

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} node
 * @return {void} Do not return anything, modify node in-place instead.
 */
var deleteNode = function(node) {
    let next = node.next;
    node.val = next.val;
    node.next = node.next.next;
};
```


### 4. 分割链表

编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。

示例:

	输入: head = 3->5->8->5->10->2->1, x = 5
	输出: 3->1->2->10->5->5->8


### 解题思路
	
1. 头插法
2. 尾插法
3. 快慢指针






### 错误原因：

```javascript
function del(node, prevNode) {
  if (prevNode) {
    prevNode.next = node.next
    node.next = null
  }
  return node
}

var partition = function(head, x) {
    if(!head || !head.next) return head
    let h = new ListNode(null);
    let pre = h;
    let cur = head;
    while(cur) {
        if(cur.val < x) {
            let node  = del(cur, pre);
            node.next = h.next;
            h.next = node;
        }
        pre = pre.next;
        cur = cur.next;
    }
    return h.next;
};
```









### 5. 移除重复节点
编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

示例1:

	 输入：[1, 2, 3, 3, 2, 1]
	 输出：[1, 2, 3]
示例2:

	 输入：[1, 1, 1, 1, 2]
	 输出：[1, 2]



### 6. 合并两个有序链表


将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例：

	输入：1->2->4, 1->3->4
	输出：1->1->2->3->4->4

### 错误写法：

错误原因： 需要返回的是头结点


```javascript
var mergeTwoLists = function(l1, l2) {
    let  l  = new ListNode();
    while(l1 && l2) {
        if(l1.val < l2.val) {
            l.next = l1;
            l1 = l1.next;
        }else {
            l.next = l2;
            l2 = l2.next;
        }
        l = l.next;
    }
    if(l1) {
        l.next = l1
    }
    if(l2) {
        l.next = l2
    }
    return l
};
```



### 解题思路
使用一个指针赋值，一个指针保存头结点  
时间复杂度：O(a+b) 循环比较两个子问题的次数为 a+b a,b为两个子问题的长度  
空间复杂度：O(1) 双指针，常数级别复杂度   

### 代码

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    let  l  = new ListNode();
    let head = l;
    while(l1 && l2) {
        if(l1.val < l2.val) {
            l.next = l1;
            l1 = l1.next;
        }else {
            l.next = l2;
            l2 = l2.next;
        }
        l = l.next;
    }
    if(l1) {
        l.next = l1
    }
    if(l2) {
        l.next = l2
    }
    return head.next;
};
```


### 7. 删除链表的节点
给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

示例 1:

	输入: head = [4,5,1,9], val = 5
	输出: [4,1,9]
	解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
示例 2:

	输入: head = [4,5,1,9], val = 1
	输出: [4,5,9]
	解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.

### 解题思路

时间复杂度 O(N) 空间复杂度O(1)

### 代码

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
var deleteNode = function(head, val) {
    let p1 =  head;
    let p2 = head.next;
    if(head.val == val) {
        head = head.next;
        return head
    }
    else {
        while(p2) {
            if(p2.val == val) {
                p1.next = p2.next
                return head
            }
            else {
                p1 = p1.next;
                p2 = p2.next;
            }
        }
    }
};
```




### 8.反转链表

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

 

示例:

	输入: 1->2->3->4->5->NULL
	输出: 5->4->3->2->1->NULL
 

限制：

	0 <= 节点个数 <= 5000

### 解题思路

### 原地双指针
使用双指针，当前指针cur, 它的前指针 pre
保存cur.next
每次 让cur指针的next指向pre
局部反转完成后，pre和cur向前移动一个位置
循环上述过程，直至pre到达链表尾部

### 代码

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    let pre = null;
    let cur = head;
    let t = null;
    while(cur) {
        t = cur.next;
        cur.next = pre;
        pre = cur;
        cur = t; 
    }
    return pre;
};
```
### 头插法

每次生成一个新节点，插入到新链表的头部

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    let new_head = null;
    let cur = head;
    while(cur) {
        let node = new ListNode(cur.val);
        node.next = new_head;
        new_head = node;
        cur = cur.next;
    }
    return new_head;
};
```



### 9. 合并两个排序的链表

输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

示例1：

	输入：1->2->4, 1->3->4
	输出：1->1->2->3->4->4

### 解题思路
思路很简单，新建一个新链表，比较l1, l2 当前位置的val, 谁小插入谁  
注意点，边际情况，当 l1 l2 均为空的时候，注意使用head 保存头结点   
注意，每次新链表节点，也要移动到当前位置	
注意l1或者l2 有一个遍历完的情况	

时间复杂度 O(M+N)： M, NM,N 分别为链表 l1、l2长度

空间复杂度 O(1)

### 代码

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    if(l1 == null && l2 == null) return null;
    let p = new ListNode();
    let head = p;
    while(l1 && l2) {
        if(l1.val < l2.val) {
            p.next = l1;
            l1 = l1.next;
        }else {
            p.next = l2;
            l2 = l2.next;
        }
        p = p.next;
    }
    if(l1) {
        p.next = l1;
    }
    if(l2) {
        p.next = l2;
    }
    return head.next;
};
```

### 10. 删除链表的倒数第N个节点

给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：

	给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
说明：

给定的 n 保证是有效的。

进阶：

你能尝试使用一趟扫描实现吗？

### 解题思路

删除链表、数组中倒数第n个节点，我们使用快慢指针，快指针比慢指针多走n步，当快指针走到尾部时，慢指针执行我们想要的元素
但是由于在链表中，我们需要的是，删除的节点的pre节点，所以两个指针需要相隔 n+1步
考虑链表长度为 n 时，无法相隔 n+ 1 步，我们给链表添加个头结点

### 代码

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
    let pre = new ListNode();
    pre.next = head;
    let new_head = pre;
    for(let i = 0; i < n; i++) {
        head = head.next;
    }
    while(head){
        head = head.next;
        pre = pre.next
    }
    pre.next = pre.next.next;
    return new_head.next;
};
```



### 11. 链表中倒数第k个节点

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。

 

示例：
	
	给定一个链表: 1->2->3->4->5, 和 k = 2.
	
	返回链表 4->5.



### 解题思路
快慢指针主要解决链表中的问题，让快指针先走 k 步，然后快慢指针开始同速前进。
这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点（为了简化，假设 k 不会超过链表长度）

注意边界测试用例

### 代码

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var getKthFromEnd = function(head, k) {
    var low = head;
    var high = head;
    for(var i = 0; i < k; i++) {
        high = high.next
    }
    while( high ) {
        low = low.next;
        high = high.next;
    }
    return low
};
```





