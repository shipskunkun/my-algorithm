## 2. 链表


	141. 环形链表
	142. 环形链表 II  
	3. 删除中间节点
	4. 分割链表
	5. 移除重复节点
	21. 合并两个有序链表




<hr>

### 141. 环形链表

给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

 

示例 1：

	输入：head = [3,2,0,-4], pos = 1
	输出：true
解释：链表中有一个环，其尾部连接到第二个节点。


### 解题思路
#### 方法一

利用set， set中的每一个值都是唯一的，遍历链表，如果 set中有节点曾经访问过，则证明有环  
时间复杂度：O(n)，对于含有 n 个元素的链表，我们访问每个元素最多一次。添加一个结点到哈希表中只需要花费 O(1) 的时间。   
空间复杂度：O(n)，空间取决于添加到哈希表中的元素数目，最多可以添加 n 个元素。  

### 代码
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    let s = new Set();

    while(head) {
        if(! s.has(head)) {
            s.add(head)
            head = head.next
        }
        else {
            return true
        }
    }
    return false
};
```



#### 方法二

快慢指针，设置快慢两个指针，遍历单链表，快指针一次走两步，慢指针一次走一步，如果单链表中存在环，则快慢指针终会指向同一个节点，否则直到快指针指向 null 时，快慢指针都不可能相遇

时间复杂度：O(n)， n 为链表中结点的总数。  
空间复杂度：O(1)，我们只使用了慢指针和快指针两个结点，所以空间复杂度为 O(1)。


### 代码

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    if(!head || !head.next) return false
    let slow = head;
    let fast = head;
    fast = fast.next.next;
    while(slow !== fast) {
        if(!fast || !fast.next) return false
        slow = slow.next;
        fast = fast.next.next;
    }
    return true;
};
```

### 142.环形链表 II


给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。

 

示例 1：

	输入：head = [3,2,0,-4], pos = 1
	输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：

	输入：head = [1,2], pos = 0
	输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个节点。


### 错误代码

错误提示： 时间超出，
错误原因： 不能让 fast 先走两步，把这个放到循环里面！



/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function(head) {
    if(!head || !head.next) return null
    let slow = head;
    let fast = head.next.next;
    while( slow != fast) {
        if(!fast || !fast.next) return null
        fast = fast.next.next;
        slow = slow.next;
    }
    fast = head;
    while(slow != fast) {
        fast = fast.next;
        slow = slow.next;
    }
    return slow
};



### 解题思路
#### 方法一

利用set， set中的每一个值都是唯一的，遍历链表，如果 set中有节点曾经访问过，立即返回改节点

时间复杂度：O(n)，对于含有 n 个元素的链表，我们访问每个元素最多一次。添加一个结点到哈希表中只需要花费 O(1) 的时间。   
空间复杂度：O(n)，空间取决于添加到哈希表中的元素数目，最多可以添加 n 个元素。  

#### 代码

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function(head) {
    let s = new Set();
    while(head) {
        if(!s.has(head)) {
            s.add(head)
            head =  head.next
        }
        else {
            return head
        }
    }
    return null
};
```

#### 方法二
快慢指针，设置快慢两个指针，遍历单链表，快指针一次走两步，慢指针一次走一步，如果单链表中存在环，则快慢指针终会指向同一个节点，否则直到快指针指向 null 时，快慢指针都不可能相遇

当他们相遇时，经过验证，此时从head 和 相遇节点，同步前行，能到达环节点

慢指针在环外路程，a
慢指针和快指针在环内路程，b
相遇节点到环节点路程，c

fast 路程是 slow 两倍
2*(a+b) =  a + b + c + b
a = c

时间复杂度：O(n)， n 为链表中结点的总数。  
空间复杂度：O(1)，我们只使用了慢指针和快指针两个结点，所以空间复杂度为 O(1)。

#### 代码

```javascript
var detectCycle = function(head) {
    if(!head || !head.next) return null
    let slow = head;
    let fast = head;
    while(fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if(slow == fast) {
            fast = head;
            while(slow != fast) {
                slow = slow.next;
                fast = fast.next;
            }
            return slow
        }
    }
    return null
};

```

面试题 02.03. 删除中间节点

实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。

 

示例：

	输入：单向链表a->b->c->d->e->f中的节点c
	结果：不返回任何数据，但该链表变为a->b->d->e->f

### 解题思路

删除该节点，又不给该节点的前指针，所以我们可以删除下一个节点，然后让此节点的值 = 下一个节点的值


### 代码

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} node
 * @return {void} Do not return anything, modify node in-place instead.
 */
var deleteNode = function(node) {
    let next = node.next;
    node.val = next.val;
    node.next = node.next.next;
};
```


### 面试题 02.04. 分割链表

编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。

示例:

	输入: head = 3->5->8->5->10->2->1, x = 5
	输出: 3->1->2->10->5->5->8


### 解题思路
	
1. 头插法
2. 尾插法
3. 快慢指针






### 错误原因：

```javascript
function del(node, prevNode) {
  if (prevNode) {
    prevNode.next = node.next
    node.next = null
  }
  return node
}

var partition = function(head, x) {
    if(!head || !head.next) return head
    let h = new ListNode(null);
    let pre = h;
    let cur = head;
    while(cur) {
        if(cur.val < x) {
            let node  = del(cur, pre);
            node.next = h.next;
            h.next = node;
        }
        pre = pre.next;
        cur = cur.next;
    }
    return h.next;
};
```









### 面试题 02.01. 移除重复节点
编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

示例1:

	 输入：[1, 2, 3, 3, 2, 1]
	 输出：[1, 2, 3]
示例2:

	 输入：[1, 1, 1, 1, 2]
	 输出：[1, 2]



### 21. 合并两个有序链表


将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例：

	输入：1->2->4, 1->3->4
	输出：1->1->2->3->4->4

### 错误写法：

错误原因： 需要返回的是头结点


```javascript
var mergeTwoLists = function(l1, l2) {
    let  l  = new ListNode();
    while(l1 && l2) {
        if(l1.val < l2.val) {
            l.next = l1;
            l1 = l1.next;
        }else {
            l.next = l2;
            l2 = l2.next;
        }
        l = l.next;
    }
    if(l1) {
        l.next = l1
    }
    if(l2) {
        l.next = l2
    }
    return l
};
```



### 解题思路
使用一个指针赋值，一个指针保存头结点  
时间复杂度：O(a+b) 循环比较两个子问题的次数为 a+b a,b为两个子问题的长度  
空间复杂度：O(1) 双指针，常数级别复杂度   

### 代码

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    let  l  = new ListNode();
    let head = l;
    while(l1 && l2) {
        if(l1.val < l2.val) {
            l.next = l1;
            l1 = l1.next;
        }else {
            l.next = l2;
            l2 = l2.next;
        }
        l = l.next;
    }
    if(l1) {
        l.next = l1
    }
    if(l2) {
        l.next = l2
    }
    return head.next;
};
```










