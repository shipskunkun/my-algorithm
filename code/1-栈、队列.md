## 0-栈、队列

	1. 化栈为队
	144. 二叉树的前序遍历
	146. LRU缓存机制
	155. 最小栈
	31. 栈的压入、弹出序列
	32. 从上到下打印二叉树



### 1. 化栈为队

实现一个MyQueue类，该类用两个栈来实现一个队列。


示例：

	MyQueue queue = new MyQueue();
	
	queue.push(1);
	queue.push(2);
	queue.peek();  // 返回 1
	queue.pop();   // 返回 1
	queue.empty(); // 返回 false

说明：

你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。


### 方法一，数组实现队

``` JavaScript
/**
 * Initialize your data structure here.
 */

var MyQueue = function() {
    this.arr = [];
};
/**
 * Push element x to the back of queue. 
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
    this.arr.push(x);
};

/**
 * Removes the element from in front of queue and returns that element.
 * @return {number}
 */
MyQueue.prototype.pop = function() {
    return this.arr.shift()
};

/**
 * Get the front element.
 * @return {number}
 */
MyQueue.prototype.peek = function() {
    return this.arr[0]
};

/**
 * Returns whether the queue is empty.
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
    return this.arr.length == 0;
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */
```
 
 
### 2. 144. 二叉树的前序遍历

 给定一个二叉树，返回它的 前序 遍历。

 示例:

	输入: [1,null,2,3]  
	   1
	    \
	     2
	    /
	   3 
	
	输出: [1,2,3]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？


### 错误写法， 错误原因：
输入[3,1,2] ，期望： [3,1,2]，结果：[3,2,1]


```javascript
var preorderTraversal = function(root) {
    let arr = [];
    let stack = [];
    if(!root) return [];
    stack.push(root);
    while(stack.length) {
        let node = stack.pop();
        arr.push(node.val);
        node && node.left && stack.push(node.left);
        node && node.right && stack.push(node.right);
    }
    return arr;
};
```

### 解题思路
递归：自己调用自己   
迭代：总是和 for 、while 有关，既然是利用栈，就要注意，结束条件，先入后出，先押入右孩子

### 递归
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    let arr = [];
    preNode(root, arr);
    return arr;
};

function preNode (root, arr) {
    if(!root) return
    arr.push(root.val);
    preNode(root.left, arr);
    preNode(root.right, arr);
} 
```


### 迭代

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
// 思路： while stack, 何时pop, 何时push

var preorderTraversal = function(root) {
    let arr = [];
    let stack = [];
    if(!root) return [];
    stack.push(root);
    while(stack.length) {
        let node = stack.pop();
        arr.push(node.val);
        node && node.right && stack.push(node.right);
        node && node.left && stack.push(node.left);
    }
    return arr;
};
```
 
 
### 2. LRU缓存机制
 
 运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。

获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

 

进阶:

你是否可以在 O(1) 时间复杂度内完成这两种操作？

 

示例:

	LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );
	
	cache.put(1, 1);
	cache.put(2, 2);
	cache.get(1);       // 返回  1
	cache.put(3, 3);    // 该操作会使得密钥 2 作废
	cache.get(2);       // 返回 -1 (未找到)
	cache.put(4, 4);    // 该操作会使得密钥 1 作废
	cache.get(1);       // 返回 -1 (未找到)
	cache.get(3);       // 返回  3
	cache.get(4);       // 返回  4

### 错误示范
	["LRUCache","put","put","put","put","get","get"]
	[[2],[2,1],[1,1],[2,3],[4,1],[1],[2]]
	 
	 me:
	 [null,null,null,null,null,1,-1]
	 
	 [null,null,null,null,null,-1,3]
	 
1. key 和 value 不一定一样
2. put 不一定是新增，可以是替换
2. 替换的时候，也要提到队顶
	 
	 
### 解题思路
![407408-20180321102219351-2030402661.png](https://pic.leetcode-cn.com/82735c8a4e537c38ee6c2439dfa0dcf3088bd08401c59a29aa8efc61bce9ad57-407408-20180321102219351-2030402661.png)


使用队列存储，LRU

get(key)：如果队列中存在key，返回对应的value，并且把它放到顶部，如果不存在，返回 -1

put(key)：如果队列中存在key，删除节点原来的位置，并且把它放到顶部  
          如果队列中不存在key，把它放到顶部, 此时判断队的长度，如果超过队长度，把尾节点删除。  
          
map, this.map.keys()返回的是一个迭代器，使用next()可以返回第一个访问结果， {done:false, value: ""}

### 方法一，使用数组

``` javascript
 /**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
    this.arr = [];
    this.maxLength = capacity;
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
    let index = this.findIndex(key);
    if(index > -1) {
        let s = this.arr.splice(index, 1)[0];
        this.arr.push(s);
        return s[1];
    }
    return -1 
};
LRUCache.prototype.findIndex = function(key) {
    let index = this.arr.findIndex(function(value, index) {
        return value[0] == key
    })
    return index
}

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
    //是替换还是新增
    let index = this.findIndex(key)
    if(index > -1) {
        let s = this.arr.splice(index, 1)[0];
    }
    this.arr.push([key, value]);
    if(this.arr.length > this.maxLength) {
        this.arr.shift();
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
``` 
 
 
### map 傻瓜版本

``` javascript
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
    this.map = new Map();
    this.maxLength = capacity;
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
    if(this.map.has(key)) {
        let value = this.map.get(key);
        this.map.delete(key);
        this.map.set(key, value);
        return value;
    }
    return -1 
};


/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
    if (this.map.has(key)) {
        this.map.delete(key)
    }
    this.map.set(key, value);
    if(this.map.size > this.maxLength) {
        let keys = [...this.map.keys()];
        this.map.delete(keys[0])
    }

};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```
 
### map 终极版本
 
```javascript
 /**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
    this.map = new Map();
    this.maxLength = capacity;
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
    if(this.map.has(key)) {
        let value = this.map.get(key);
        this.map.delete(key);
        this.map.set(key, value);
        return value;
    }
    return -1 
};


/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
    if (this.map.has(key)) {
        this.map.delete(key)
    }
    this.map.set(key, value);
    if(this.map.size > this.maxLength) {
        this.map.delete(this.map.keys().next().value);
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```


### 4. 最小栈

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。
 

示例:
	
	输入：
	["MinStack","push","push","push","getMin","pop","top","getMin"]
	[[],[-2],[0],[-3],[],[],[],[]]
		
	输出：
	[null,null,null,null,-3,null,0,-2]
		
	解释：
	MinStack minStack = new MinStack();
	minStack.push(-2);
	minStack.push(0);
	minStack.push(-3);
	minStack.getMin();   --> 返回 -3.
	minStack.pop();
	minStack.top();      --> 返回 0.
	minStack.getMin();   --> 返回 -2.
 
 

提示：

pop、top 和 getMin 操作总是在 非空栈 上调用。

### 解题思路

因为题目要求，执行push、pop和min操作的时间复杂度必须为O(1)。

所以，如果每次 pop 后，对原数组重新排序，来获得最小值，不符合要求

我们重新构建一个最小值栈，当前栈的最小值，通过获取 最小值栈顶即可。

当原栈为   [-2, 0, -3] 

最小值栈为  [-2, -2, -3]


### 代码

```javascript

/**
 * initialize your data structure here.
 */
var MinStack = function() {
    this.arr = [];
    this.min = [];
};

/** 
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
    if(!this.min.length) {
        this.min.push(x);
    }
    else {
        let y = this.min[this.min.length - 1];
        if(x > y) {
            this.min.push(y)
        }else {
            this.min.push(x)
        }
    }
    this.arr.push(x);
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
    this.arr.pop();
    this.min.pop();
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
    return this.arr[this.arr.length - 1]
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
    return this.min[this.min.length - 1];
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */
```

### 5. 栈的压入、弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

 

示例 1：

	输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
	输出：true
	解释：我们可以按以下顺序执行：
	push(1), push(2), push(3), push(4), pop() -> 4,
	push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
示例 2：

	输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
	输出：false
	解释：1 不能在 2 之前弹出。

### 错误案例

输入：[][]  
预期：true  
输出：false  



### 解题思路
![img](https://pic.leetcode-cn.com/c880f045c03a8e03b7908b2d49b658a9a32ba8f5d40cb19da62db32c7eb58830-Picture1.png)

算法思路，就是使用一个新的栈，按照pushed 顺序向 stack 里面压数据，如果 栈顶 = pop当前位置的值，
stack pop， 最后，如果按照 poped 的规则，stack 能清空，就是true

编程思路： 

1. 当 pushed 没有遍历完 pushed.length，向 stack 中 push
2. 一直到 pop[j] == stack.top
3. 如果 pop[j] == stack.top,  stack.pop
4. pop 中 j + 1
5. 此时，push 遍历完成，返回 stack是否为空


### 代码

```javascript
/**
 * @param {number[]} pushed
 * @param {number[]} popped
 * @return {boolean}
 */
                                                                                                                     
var validateStackSequences = function(pushed, popped) {
    let l = pushed.length;
    let stack = [];
    let j = 0;
    for(let i= 0; i < l; i++) {
        stack.push(pushed[i])
        while(stack.length && stack[stack.length - 1] == popped[j]) {
            stack.pop();
            j++;
        }
    }
    return !stack.length
};
```



### 6. 从上到下打印二叉树

从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。

 

例如:
	给定二叉树: [3,9,20,null,null,15,7],
	
	    3
	   / \
	  9  20
	    /  \
	   15   7
	返回：
	
	[3,9,20,15,7]


### 解题思路

队列层次遍历

### 代码

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 * 
 */
var levelOrder = function(root) {
    let arr = [];
    if(!root) {
        return arr;
    }
    let q = [root];
    while(q.length) {
        let cur = q.shift();
        arr.push(cur.val);
        cur.left && q.push(cur.left);
        cur.right && q.push(cur.right);
    }
    return arr;
};
```


### 7. 有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

	示例 1:
	输入: "()"
	输出: true
	
	示例 2:
	输入: "()[]{}"
	输出: true
	
	示例 3:
	输入: "(]"
	输出: false
	
	示例 4:
	输入: "([)]"
	输出: false



### 错误答案

```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    let map = {")": "(", "}": "{", "]" : "["};
    let stack = [];
    for(let i of s) {
        if( !map[i]) {
            stack.push(i);
        }
        else {
            if(map[i] == stack[stack.length - 1]) {
                stack.pop();
            }
        }
    }
    return !stack.length
};
```

错误的例子：

输入

"]"

期待：false
我： true, 

因为我不在map中的，我没有放进去



"()"

实际： true, 我 false


"(])"

### 改后， 如果是左括号，入栈，否则，和栈顶元素想匹配


```javascript
var isValid = function(s) {
    let map = {'{': '}','(': ')','[': ']'}
    let stack = []
    for(let i = 0; i < s.length ; i++) {
        if(map[s[i]]) {
            stack.push(s[i])
        } else if(s[i] !== map[stack.pop()]){
            return false
        }
    }
    return stack.length === 0
}
```