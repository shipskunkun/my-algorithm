# 4.12-4.18


###1. 合并排序的数组


给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。

初始化 A 和 B 的元素数量分别为 m 和 n。

示例:

输入:
A = [1,2,3,0,0,0], m = 3
B = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
说明:

A.length == n + m

###解题思路


对于数组的操作，效率比较高的是，数组头部或者尾部操作	
已知合并后的数组长度，那么我们从数组后面操作	
注意边界值，k>=0，m 可能为0， n 可能为0 的情况	
for循环执行步骤	

```
代码
/**
 * @param {number[]} A
 * @param {number} m
 * @param {number[]} B
 * @param {number} n
 * @return {void} Do not return anything, modify A in-place instead.
 */
var merge = function(A, m, B, n) {
    var i  = m - 1;
    var j = n - 1;
    //从A尾部操作，每次确定最后一个数
    for(var k = m + n - 1; k >= 0; k--) {
        if(i > -1 && j > -1) {
            if(A[i] < B[j]) {
                A[k] = B[j--];
            }else {
                A[k] = A[i--];
            }
        }else if(i > -1) {
            A[k] = A[i--];
        }else {
            A[k] = B[j--]
        }
    }
    return A;
};

```

###2. 数组中重复的数字

找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

示例 1：

输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
 

限制：

2 <= n <= 100000

###解题思路

map, key不重复的，值-值，数据结构		
然后注意，for的边境，i=nums.length - 1 要执行		

```
代码
/**
 * @param {number[]} nums
 * @return {number}
 */
var findRepeatNumber = function(nums) {
    var map = new Map();
    for(var i = 0; i < nums.length ; i++) {
        if(!map.has(nums[i])) {
            map.set(nums[i], true)
        }else{
            return nums[i]
        }
    }
};

```

###3.  删除排序数组中的重复项

给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

 

示例 1:

给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
示例 2:

给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。

###解题思路
显然，由于数组已经排序，所以重复的元素一定连在一起，找出它们并不难，但如果毎找到一个重复元素就立即删除它，就是在数组中间进行删除操作，整个时间复杂度是会达到 O(N^2)。而且题目要求我们原地修改，也就是说不能用辅助数组，空间复杂度得是 O(1)

其实，对于数组相关的算法问题，有一个通用的技巧：要尽量避免在中间删除元素，那我就想先办法把这个元素换到最后去。这样的话，最终待删除的元素都拖在数组尾部，一个一个 pop 掉就行了，每次操作的时间复杂度也就降低到 O(1) 了。

按照这个思路呢，又可以衍生出解决类似需求的通用方式：双指针技巧。具体一点说，应该是快慢指针。

我们让慢指针 slow 走左后面，快指针 fast 走在前面探路，找到一个不重复的元素就告诉 slow 并让 slow 前进一步。这样当 fast 指针遍历完整个数组 nums 后，nums[0..slow] 就是不重复元素，之后的所有元素都是重复元素。

```
代码
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    if(nums.length == 0) return 0;
    var i = 0;
    var j = 1;
    while(j < nums.length) {
        if(nums[i] != nums[j]) {
            i++
            nums[i] = nums[j]
        }
        j++
    }
    return i + 1
};
```


### 4. 合并有序数组A


