## 读算法小抄

1. 什么是迭代递归
	
		迭代是逐渐逼近，用新值覆盖旧值，直到满足条件后结束，不保存中间值，空间利用率高。
		
		迭代：循环结构，例如for，while循环
		迭代是更新变量的旧值。
		
		
		递归是将一个问题分解为若干相对小一点的问题，遇到递归出口再原路返回，因此必须保存相关的中间值，这些中间值压入栈保存，问题规模较大时会占用大量内存。
		
		递归是在函数内部调用自身


2. 数据结构的遍历和访问

		先行就是 for/while ,迭代（如数组）链表（递归+迭代）
		非线性就是 递归。（二叉树）


3. 动态规划核心
	
		备忘录+正确状态转移方程
	
		首先，动态规划的穷举有点特别，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。
	
		而且，动态规划问题一定会具备「最优子结构」，才能通过子问题的最值得到原问题的最值。
		
		另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出正确的「状态转移方程」才能正确地穷举。



4. 对于数组相关的算法问题，有一个通用的技巧：要尽量避免在中间删除元素，那我就想先办法把这个元素换到最后去。




5. 时间复杂度


递归算法的时间复杂度怎么计算？子问题个数乘以解决一个子问题需要的时间。

子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。

解决一个子问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) 一个加法操作，时间为 O(1)。

所以，这个算法的时间复杂度为 O(2^n)，指数级别，爆炸。

带备忘录的递归：
	
	本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。
	

